var documenterSearchIndex = {"docs":
[{"location":"reference/experimental/#Experimental-APIs","page":"Experimental APIs","title":"Experimental APIs","text":"ðŸ‰ Hic Sunt Dracones\n\nThe JuliaHub.Experimental module contains various experimental APIs.","category":"section"},{"location":"reference/experimental/#Reference","page":"Experimental APIs","title":"Reference","text":"","category":"section"},{"location":"reference/experimental/#JuliaHub.Experimental","page":"Experimental APIs","title":"JuliaHub.Experimental","text":"module Experimental\n\nHome for experimental JuliaHub.jl APIs.\n\nwarning: Unstable APIs\nThese APIs are considered highly unstable. Both JuliaHub platform version changes, and also JuliaHub.jl package changes may break these APIs at any time. Depend on them at your own peril.\n\n\n\n\n\n","category":"module"},{"location":"reference/experimental/#JuliaHub.Experimental.Registry","page":"Experimental APIs","title":"JuliaHub.Experimental.Registry","text":"struct Registry\n\nRepresents a Julia package registry on JuliaHub.\n\nwarning: Unstable API\nThis API is not part of the public API and does not adhere to semantic versioning.This APIs is considered highly unstable. Both JuliaHub platform version changes, and also JuliaHub.jl package changes may break it at any time. Depend on it at your own peril.\n\n\n\n\n\n","category":"type"},{"location":"reference/experimental/#JuliaHub.Experimental.registries","page":"Experimental APIs","title":"JuliaHub.Experimental.registries","text":"JuliaHub.Experimental.registries() -> Vector{Experimental.Registry}\n\nReturn the list of registries configured on the JuliaHub instance.\n\nwarning: Unstable API\nThis API is not part of the public API and does not adhere to semantic versioning.This APIs is considered highly unstable. Both JuliaHub platform version changes, and also JuliaHub.jl package changes may break it at any time. Depend on it at your own peril.\n\n\n\n\n\n","category":"function"},{"location":"reference/experimental/#JuliaHub.Experimental.register_package","page":"Experimental APIs","title":"JuliaHub.Experimental.register_package","text":"JuliaHub.Experimental.register_package(\n    auth::Authentication,\n    registry::Union{AbstractString, Registry},\n    repository_url::AbstractString;\n    # Optional keyword arguments:\n    [notes::AbstractString,]\n    [branch::AbstractString,]\n    [subdirectory::AbstractString,]\n    [git_server_type::AbstractString]\n) -> String | Nothing\n\nInitiates a registration PR of the package at repository_url in Returns the URL of the registry PR, or nothing if the registration failed.\n\nExample\n\nusing JuliaHub\nauth = JuliaHub.authenticate(\"juliahub.com\")\nJuliaHub._registries(auth)\n\nr = JuliaHub.Experimental.register_package(\n    auth,\n    \"MyInternalRegistry\",\n    \"https://github.com/MyUser/MyPackage.jl\";\n    notes = \"This was initiated via JuliaHub.jl\",\n)\n\nwarning: Unstable API\nThis API is not part of the public API and does not adhere to semantic versioning.This APIs is considered highly unstable. Both JuliaHub platform version changes, and also JuliaHub.jl package changes may break it at any time. Depend on it at your own peril.\n\n\n\n\n\n","category":"function"},{"location":"reference/authentication/#authentication","page":"Authentication","title":"Authentication","text":"In order to talk to a JuliaHub instance, you need to have a valid authentication token. JuliaHub reuses the Julia's built-in package server authentication tokens for this purpose. By default, the authentication uses the JULIA_PKG_SERVER environment variable to determine which JuliaHub instance to connect to, but this can be overridden by passing an argument to authenticate.\n\nThe authenticate function can be used to construct a token. If a valid token is available in ~/.julia/servers, it gets reused. Otherwise, a browser window is opened, starting an interactive authentication procedure.\n\nAll the functions that require authentication accept an auth keyword argument. However, JuliaHub.jl also stores the authentication token from the last authenticate call in a global variable and automatically uses that if auth is not provided, and also tries to authenticate automatically. The current global authentication object can be accessed via the current_authentication() function.\n\nSee also: authentication guide, authentication section on help.juliahub.com, PkgAuthentication.","category":"section"},{"location":"reference/authentication/#Token-expiration-and-refresh-tokens","page":"Authentication","title":"Token expiration and refresh tokens","text":"By default, JuliaHub access tokens expire in 24 hours. However, the tokens usually also have a refresh token, which is valid for 30 days. If the access token has expired, but there is a valid refresh token available, authenticate will automatically try to use that, to re-acquire an access token without starting an interactive authentication.\n\nIn JuliaHub job and cloud IDE environments, the authentication token on disk will be continuously kept up to date. The reauthenticate! function can be used to reload the token from disk.","category":"section"},{"location":"reference/authentication/#Reference","page":"Authentication","title":"Reference","text":"","category":"section"},{"location":"reference/authentication/#Index","page":"Authentication","title":"Index","text":"Pages = [\"authentication.md\"]\n\n","category":"section"},{"location":"reference/authentication/#JuliaHub.authenticate","page":"Authentication","title":"JuliaHub.authenticate","text":"JuliaHub.authenticate(\n    server::AbstractString = Pkg.pkg_server();\n    force::Bool = false,\n    maxcount::Integer = 3,\n    [project::Union{AbstractString, UUIDs.UUID, Nothing}],\n    [hook::Base.Callable]\n) -> JuliaHub.Authentication\nJuliaHub.authenticate(server::AbstractString, token::Union{AbstractString, JuliaHub.Secret}) -> JuliaHub.Authentication\n\nAuthenticates with a JuliaHub server, returning a JuliaHub.Authentication object and setting the global authentication session (see JuliaHub.current_authentication). May throw an AuthenticationError if the authentication fails (e.g. expired token).\n\nThe zero- and one-argument methods will attempt to read the token from the current Julia depot. If a valid authentication token does not exist in the Julia depot, a new token is acquired via an interactive browser based prompt. By default, it attemps to connect to the currently configured Julia package server URL (configured e.g. via the JULIA_PKG_SERVER environment variable), but this can be overridden by passing the server argument.  server is just the URL of your JuliaHub instance, so if you've logged on to the public JuliaHub server, this is \"juliahub.com\".\n\nThe two-argument method can be used when you do not want to read the token from the auth.toml file (e.g. when using a long-term token via an environment variable). In this case, you also have to explicitly set the server URL and JULIA_PKG_SERVER is ignored.\n\nExtended help\n\nThe interactive prompts tries to authenticate for a maximum of maxcount times. If force is set to true, an existing authentication token is first deleted. This can be useful when the existing authentication token is causing the authentication to fail.\n\nhook can be set to a function taking a single string-type argument, and will be passed the authorization URL the user should interact with in the browser. This can be used to override the default behavior coming from PkgAuthentication.\n\nThe returned Authentication object is also cached globally (overwriting any previously cached authentications), making it unnecessary to pass the returned object manually to other function calls. This is useful for interactive use, but should not be used in library code, as different authentication calls may clash.\n\nProject Context\n\nAn Authentication object can also specify the default JuliaHub project. This can be set by passing the optional project argument, which works as follows:\n\nIf the project value is not passed, JuliaHub.jl will attempt to pick up the the project UUID from the JULIAHUB_PROJECT_UUID environment variable, and will fall back to the non-project context if that is not set.\nIf you pass an explicit UUID (either as a string or an UUID object), that will then be used as the project. Note that a UUID passed as a string must be a syntactically correct UUID.\nPassing nothing makes JuliaHub.jl ignore any values in the JULIAHUB_PROJECT_UUID environment variable.\n\nnote: JULIAHUB_PROJECT_UUID\nGenerally, in JuliaHub jobs and cloud IDE environments that are launched in the context of a project, the JULIAHUB_PROJECT_UUID is automatically set, and JuliaHub.jl will pick it up automatically, unless explicitly disabled with project=nothing.\n\nwarn: Project access checks\nWhen the Authentication object is constructed, access to or existence of the specified project is not checked. However, if you attempt any project operations with with such an authentication object, they will fail and throw an error.\n\nExamples\n\nIf JULIA_PKG_SERVER is set, authenticate() will pick it up automatically, although it can also be overridden by setting the instance hostname explicitly:\n\njulia> ENV[\"JULIA_PKG_SERVER\"]\n\"juliahub.com\"\n\njulia> JuliaHub.authenticate()\nJuliaHub.Authentication(\"https://juliahub.com\", \"username\", *****)\n\njulia> JuliaHub.authenticate(\"mycompany.juliahub.com\")\nJuliaHub.Authentication(\"https://mycompany.juliahub.com\", \"username\", *****)\n\nIf JULIAHUB_PROJECT_UUID is set to point to a JuliaHub Project (e.g. in JuliaHub cloud environments), it will also get automatically picked up, but can also be overridden:\n\njulia> ENV[\"JULIAHUB_PROJECT_UUID\"]\n\"b1a95ba8-43e6-4eb6-b280-3c5cbe0fa0b9\"\n\njulia> JuliaHub.authenticate()\nJuliaHub.Authentication(\"https://juliahub.com\", \"username\", *****; project_id = \"b1a95ba8-43e6-4eb6-b280-3c5cbe0fa0b9\")\n\njulia> JuliaHub.authenticate(; project = \"7ed96f69-a765-4de6-ac00-04a38684ce1c\")\nJuliaHub.Authentication(\"https://juliahub.com\", \"username\", *****; project_id = \"7ed96f69-a765-4de6-ac00-04a38684ce1c\")\n\njulia> JuliaHub.authenticate(; project = nothing)\nJuliaHub.Authentication(\"https://juliahub.com\", \"username\", *****)\n\n\n\n\n\n","category":"function"},{"location":"reference/authentication/#JuliaHub.Authentication","page":"Authentication","title":"JuliaHub.Authentication","text":"mutable struct Authentication\n\nAuthentication object constructed by the authenticate function that can be passed to the various JuliaHub.jl function via the auth keyword argument.\n\nObjects have the following properties:\n\nserver :: URIs.URI: URL of the JuliaHub instance this authentication token applies to.\nusername :: String: user's JuliaHub username (used for e.g. to namespace datasets)\ntoken :: JuliaHub.Secret: a Secret object storing the JuliaHub authentication token\nproject_id :: Union{UUID, Nothing}: the project ID of the currently active project.\n\nNote that the object is mutable, and hence will be shared as it is passed around. And at the same time, functions such as reauthenticate! may modify the object.\n\nSee also: authenticate, reauthenticate!, current_authentication.\n\ncompat: No public constructors\nObjects of this type should not be constructed explicitly. The contructor methods are not considered to be part of the public API.\n\n\n\n\n\n","category":"type"},{"location":"reference/authentication/#JuliaHub.current_authentication","page":"Authentication","title":"JuliaHub.current_authentication","text":"JuliaHub.current_authentication() -> Union{Authentication, Nothing}\n\nReturns the current globally active Authentication object, or nothing if authenticate has not yet been called.\n\njulia> JuliaHub.current_authentication()\nJuliaHub.Authentication(\"https://juliahub.com\", \"username\", *****)\n\nnote: Note\nCalling this function will not initialize authentication.\n\n\n\n\n\n","category":"function"},{"location":"reference/authentication/#JuliaHub.check_authentication","page":"Authentication","title":"JuliaHub.check_authentication","text":"JuliaHub.check_authentication(; [auth::Authentication]) -> Bool\n\nChecks if the authentication to a JuliaHub instance is still valid or not.\n\nThis can be used to periodically check an authentication token, to see if it is necessary to re-authenticate.\n\nSee also: reauthenticate!.\n\n\n\n\n\n","category":"function"},{"location":"reference/authentication/#JuliaHub.reauthenticate!","page":"Authentication","title":"JuliaHub.reauthenticate!","text":"JuliaHub.reauthenticate!([auth::Authentication]; force::Bool = false, maxcount::Integer = 3, [hook::Base.Callable])\n\nAttempts to update the authentication token in auth:\n\nIf the original auth.toml file has been updated, it simply reloads the token from the file.\nIf loading from auth.toml fails or force=true, it will attempt to re-authenticate with the server, possibly interactively.\n\nIf auth is omitted, it will reauthenticate the global Authentication object. The force, maxcount and hook are relevant for interactive authentication, and behave the same way as in the authenticate function.\n\nThis is mostly meant to be used to re-acquire authentication tokens in long-running sessions, where the initial authentication token may have expired. If the original auth object was authenticated in the context of a project (i.e. .project_id is set), the project association will be retained.\n\nAs Authentication objects are mutable, the token will be updated in all contexts where the reference to the Authentication has been passed to.\n\nSee also: authenticate, current_authentication, Authentication, check_authentication.\n\n\n\n\n\n","category":"function"},{"location":"reference/authentication/#JuliaHub.Secret","page":"Authentication","title":"JuliaHub.Secret","text":"mutable struct Secret\n\nA helper type for storing secrets. Internally it is a covenience wrapper around Base.SecretBuffer. Predominantly used in Authentication objects to store the JuliaHub authentication token.\n\nThe String(::Secret) function can be used to obtain an unsecure string copy of the secret stored in the object.\n\njulia> s = JuliaHub.Secret(\"secret-string\")\nJuliaHub.Secret(\"*******\")\n\njulia> String(s)\n\"secret-string\"\n\nConstructors\n\nSecret(::AbstractString)\nSecret(::Vector{UInt8})\n\nCreate a Secret object from the input strings.\n\n\n\n\n\n","category":"type"},{"location":"guides/datasets/#guide-datasets","page":"Datasets","title":"Datasets","text":"JuliaHub.jl offers a programmatic way to work with your JuliaHub datasets, and this section demonstrates a few common workflows you can use with these APIs.\n\nPages = [\"datasets.md\"]\nDepth = 2:10\n\nSee the datasets reference page for a detailed reference of the datasets-related functionality.","category":"section"},{"location":"guides/datasets/#Accessing-datasets","page":"Datasets","title":"Accessing datasets","text":"The datasets function can be use to list all the datasets owned by the currently authenticated user, returning an array of Dataset objects.\n\njulia> JuliaHub.datasets()\n2-element Vector{JuliaHub.Dataset}:\n JuliaHub.dataset((\"username\", \"example-dataset\"))\n JuliaHub.dataset((\"username\", \"blobtree/example\"))\n\nIf you know the name of the dataset, you can also directly access it with the dataset function, and you can access the dataset metadata via the properties of the Dataset object.\n\njulia> ds = JuliaHub.dataset(\"example-dataset\")\nDataset: example-dataset (Blob)\n owner: username\n description: An example dataset\n versions: 2\n size: 388 bytes\n tags: tag1, tag2\n\njulia> ds.owner\n\"username\"\n\njulia> ds.description\n\"An example dataset\"\n\njulia> ds.size\n388\n\nIf you want to work with dataset that you do not own but is shared with you in JuliaHub, you can pass shared=true to datasets, or specify the username.\n\njulia> JuliaHub.datasets(shared=true)\n3-element Vector{JuliaHub.Dataset}:\n JuliaHub.dataset((\"username\", \"example-dataset\"))\n JuliaHub.dataset((\"anotheruser\", \"publicdataset\"))\n JuliaHub.dataset((\"username\", \"blobtree/example\"))\n\njulia> JuliaHub.datasets(\"anotheruser\")\n1-element Vector{JuliaHub.Dataset}:\n JuliaHub.dataset((\"anotheruser\", \"publicdataset\"))\n\njulia> JuliaHub.dataset((\"anotheruser\", \"publicdataset\"))\nDataset: publicdataset (Blob)\n owner: anotheruser\n description: An example dataset\n versions: 1\n size: 57 bytes\n tags: tag1, tag2\n\nFinally, JuliaHub.jl can also be used to download to your local machine with the download_dataset function.\n\njulia> JuliaHub.download_dataset(\"example-dataset\", \"mydata\")\nTransferred:       86.767 KiB / 86.767 KiB, 100%, 0 B/s, ETA -\nTransferred:            1 / 1, 100%\nElapsed time:         2.1s\n\"/home/username/my-project/mydata\"\n\nAs datasets can have multiple versions, the .versions property of Dataset can be used to see information about the individual versions (represented with DatasetVersion objects). When downloading, you can also specify the version you wish to download (with the default being the newest version).\n\njulia> ds.versions\n2-element Vector{JuliaHub.DatasetVersion}:\n JuliaHub.dataset((\"username\", \"example-dataset\")).versions[1]\n JuliaHub.dataset((\"username\", \"example-dataset\")).versions[2]\n\njulia> ds.versions[1]\nDatasetVersion: example-dataset @ v1\n owner: username\n timestamp: 2022-10-13T01:39:42.963-04:00\n size: 57 bytes\n\njulia> JuliaHub.download_dataset(\"example-dataset\", \"mydata\", version=ds.versions[1].id)\nTransferred:       86.767 KiB / 86.767 KiB, 100%, 0 B/s, ETA -\nTransferred:            1 / 1, 100%\nElapsed time:         2.1s\n\"/home/username/my-project/mydata\"\n\n\nThe dataset version are sorted with oldest first. To explicitly access the newest dataset, you can use the last function on the .versions property.\n\njulia> last(ds.versions)\nDatasetVersion: example-dataset @ v2\n owner: username\n timestamp: 2022-10-14T01:39:43.237-04:00\n size: 331 bytes\n\n\ntip: Tip: DataSets.jl\nIn JuliaHub jobs and Cloud IDEs you can also use the DataSets.jl package to access and work with datasets. See the help.julialang.org section on datasets for more information.","category":"section"},{"location":"guides/datasets/#Create,-update,-or-replace","page":"Datasets","title":"Create, update, or replace","text":"The upload_dataset function can be used to programmatically create new datasets on JuliaHub.\n\nJuliaHub.upload_dataset(\"example-dataset\", \"local-file\")\n\nThe type of the dataset (Blob or BlobTree) depends on whether the uploaded object is a file or a directory. A directory will be stored as a BlobTree-type dataset on JuliaHub.\n\nJuliaHub.upload_dataset(\"example-blobtree\", \"local-directory\")\n\nThe create, update, and replace options control how upload_dataset behaves with respect to existing datasets. By default, the function only creates brand new datasets, and trying to upload a dataset that already exists will fail with an error.\n\nJuliaHub.upload_dataset(\"example-dataset\", \"local-file\")\n\nThis behavior can be overridden by setting update=true, which will then upload a new version of a dataset if it already exists. This is useful for jobs and workflows that are meant to be re-run, updating the dataset each time they run.\n\nJuliaHub.upload_dataset(\"example-dataset\", \"local-file\"; update=true)\n\nThe replace=true option can be used to erase earlier versions of a dataset. This will delete all information about the existing dataset and is a destructive, non-recoverable action. This may also lead to the dataset type being changed.\n\nJuliaHub.upload_dataset(\"example-dataset\", \"local-file\"; replace=true)","category":"section"},{"location":"guides/datasets/#Bulk-updates","page":"Datasets","title":"Bulk updates","text":"You can also use the package to perform bulk updates or deletions of datasets. The following example, adds a new tag to all the datasets where the name matches a particular pattern.\n\n# Find all the datasets that have names that start with 'my-analysis-'\nmyanalysis_datasets = filter(\n    dataset -> startswith(dataset.name, r\"my-analysis-.*\"),\n    JuliaHub.datasets()\n)\n# .. and now add a 'new-tag' tag to each of them\nfor dataset in myanalysis_datasets\n    @info \"Updating\" dataset\n    # Note: tags = ... overrides the whole list, so you need to manually retain\n    # old tags.\n    new_tags = [dataset.tags..., \"new-tag\"]\n    JuliaHub.update_dataset(dataset, tags = new_tags)\nend\n\nWhile this example shows the update_dataset, for example, the delete_dataset function could be used in the same way.\n\n","category":"section"},{"location":"reference/datasets/#datasets","page":"Datasets","title":"Datasets","text":"These APIs allow you to create, read, update, and delete datasets owned by the currently authenticated user.\n\nYou can use datasets, dataset, and download_dataset to access datasets or their metadata.\nupload_dataset, update_dataset, and delete_dataset can be used to create, update, or delete datasets.\n\nSee also: help.julialang.org on datasets, DataSets.jl.","category":"section"},{"location":"reference/datasets/#Dataset-types","page":"Datasets","title":"Dataset types","text":"JuliaHub currently has two distinct types of datasets:\n\nBlob: a single file; or, more abstractly, a collection of bytes\nBlobTree: a directory or a file; more abstractly a tree-like collection of Blobs, indexed by file system paths\n\nThese types mirror the concepts in DataSets.jl\n\nJuliaHub.jl APIs do not rely that much on the dataset type for anything, except when downloading or uploading. In that case, a local file always corresponds to a Blob, and a local directory corresponds to a BlobTree. For example, when trying to upload a file as a new version of a BlobTree-type dataset will fail, because the dataset type can not change.\n\nThe upload_dataset function uses information filesystem to determine whether the created dataset is a Blob or a BlobTree, and similarly download_dataset will always download a Blob into a file, and a BlobTree as a directory.","category":"section"},{"location":"reference/datasets/#Dataset-versions","page":"Datasets","title":"Dataset versions","text":"A JuliaHub dataset can have zero or more versions. A newly created dataset usually has at least one version, but it may have zero versions if, for example, the upload did not finish. The versions are indexed with a linear list of integers starting from 1.","category":"section"},{"location":"reference/datasets/#MinIO-backend","page":"Datasets","title":"MinIO backend","text":"JuliaHub instances with the MinIO backend for data storage require at least JuliaHub.jl v0.1.6 for dataset uploads and downloads.","category":"section"},{"location":"reference/datasets/#Reference","page":"Datasets","title":"Reference","text":"","category":"section"},{"location":"reference/datasets/#Index","page":"Datasets","title":"Index","text":"Pages = [\"datasets.md\"]\n\n","category":"section"},{"location":"reference/datasets/#JuliaHub.Dataset","page":"Datasets","title":"JuliaHub.Dataset","text":"struct Dataset\n\nInformation about a dataset stored on JuliaHub, and the following fields are considered to be public API:\n\nuuid :: UUID: dataset UUID\nowner :: String: username of the dataset owner\nname :: String: dataset name\ndtype :: String: generally either Blob or BlobTree, but additional values may be added in the future\nversions :: Vector{DatasetVersion}: an ordered list of DatasetVersion objects, one for each dataset version, sorted from oldest to latest (i.e. you can use last to get the newest version).\nsize :: Int: total size of the whole dataset (including all the dataset versions) in bytes\nFields to access user-provided dataset metadata:\ndescription :: String: dataset description\ntags :: Vector{String}: a list of tags\nIf the dataset was accessed via a project (e.g. via project_datasets), .project will contain project metadata (see also: DatasetProjectLink). Otherwise this field is nothing.\nproject.uuid: the UUID of the project\nproject.is_writable: whether the user has write access to the dataset via the this project\nNote that two Dataset objects are considered to be equal (i.e. ==) regardless of the .project value â€“ it references the same dataset regardless of the project it was accessed in.\n\nnote: Canonical fully qualified dataset name\nIn some contexts, like when accessing JuliaHub datasets with DataSets.jl, the .owner-.name tuple constitutes the fully qualifed dataset name, uniquely identifying a dataset on a JuliaHub instance. I.e. for a dataset object dataset, it can be constructed as \"$(dataset.owner)/$(dataset.name)\".\n\nwarning: Non-dynamic dataset objects\nDataset objects represents the dataset metadata when the Julia object was created (e.g. with dataset), and are not automatically kept up to date. To refresh the dataset metadata, you can pass an existing Dataset object to JuliaHub.dataset or project_dataset.\n\ncompat: No public constructors\nObjects of this type should not be constructed explicitly. The contructor methods are not considered to be part of the public API.\n\n\n\n\n\n","category":"type"},{"location":"reference/datasets/#JuliaHub.DatasetVersion","page":"Datasets","title":"JuliaHub.DatasetVersion","text":"struct DatasetVersion\n\nRepresents one version of a dataset.\n\nObjects have the following properties:\n\n.id: unique dataset version identifier (used e.g. in download_dataset to identify the dataset version).\n.size :: Int: size of the dataset version in bytes\n.timestamp :: ZonedDateTime: dataset version timestamp\n\njulia> dataset = JuliaHub.dataset(\"example-dataset\")\nDataset: example-dataset (Blob)\n owner: username\n description: An example dataset\n versions: 2\n size: 388 bytes\n tags: tag1, tag2\n\njulia> dataset.versions\n2-element Vector{JuliaHub.DatasetVersion}:\n JuliaHub.dataset((\"username\", \"example-dataset\")).versions[1]\n JuliaHub.dataset((\"username\", \"example-dataset\")).versions[2]\n\njulia> dataset.versions[end]\nDatasetVersion: example-dataset @ v2\n owner: username\n timestamp: 2022-10-14T01:39:43.237-04:00\n size: 331 bytes\n\nSee also: Dataset, datasets, dataset.\n\ncompat: No public constructors\nObjects of this type should not be constructed explicitly. The contructor methods are not considered to be part of the public API.\n\n\n\n\n\n","category":"type"},{"location":"reference/datasets/#JuliaHub.datasets","page":"Datasets","title":"JuliaHub.datasets","text":"JuliaHub.datasets([username::AbstractString]; shared::Bool=false, [auth::Authentication]) -> Vector{Dataset}\n\nList all datasets owned by username, returning a list of Dataset objects.\n\nIf username is omitted, it returns the datasets owned by the currently authenticated user. If username is different from the currently authenticated user, it only returns the datasets that are readable to (i.e. somehow shared with) the currently authenticated user.\n\nIf shared = true, it also returns datasets that belong to other users that have that have been shared with the currently authenticated user. In this case, username is effectively ignored.\n\njulia> JuliaHub.datasets()\n2-element Vector{JuliaHub.Dataset}:\n JuliaHub.dataset((\"username\", \"example-dataset\"))\n JuliaHub.dataset((\"username\", \"blobtree/example\"))\n\njulia> JuliaHub.datasets(shared=true)\n3-element Vector{JuliaHub.Dataset}:\n JuliaHub.dataset((\"username\", \"example-dataset\"))\n JuliaHub.dataset((\"anotheruser\", \"publicdataset\"))\n JuliaHub.dataset((\"username\", \"blobtree/example\"))\n\njulia> JuliaHub.datasets(\"anotheruser\")\n1-element Vector{JuliaHub.Dataset}:\n JuliaHub.dataset((\"anotheruser\", \"publicdataset\"))\n\nwarning: Non-dynamic dataset objects\nDataset objects represents the dataset metadata when the Julia object was created (e.g. with dataset), and are not automatically kept up to date. To refresh the dataset metadata, you can pass an existing Dataset object to JuliaHub.dataset or project_dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/datasets/#JuliaHub.DatasetReference","page":"Datasets","title":"JuliaHub.DatasetReference","text":"const DatasetReference :: Type\n\nType constraint on the first argument of most of the datasets-related functions, that is used to uniquely specify the dataset that the operation will affect.\n\nThere are three different objects that can be passed as a dataset reference (dsref::DatasetReference):\n\n(owner::AbstractString, dataset_name::AbstractString)::Tuple{AbstractString,AbstractString}\nA tuple of the owner's username and the dataset's name.\ndataset_name::AbstractString\nJust a string with the dataset name; in this case the dataset's owner will be assumed to be the currently authenticated user (with the username determined from the Authentication objects passed via the auth keyword).\ndataset::Dataset\nUses the owner and dataset name information from a Dataset object.\n\nwarning: No UUID mismatch checks\nWhen using the third option (i.e. passing a Dataset), the dataset UUID will not be checked. So if the dataset with the same owner and username has been deleted and re-created as a new dataset (potentially of a different dtype etc), the functions will then act on the new dataset.\n\n\n\n\n\n","category":"type"},{"location":"reference/datasets/#JuliaHub.dataset","page":"Datasets","title":"JuliaHub.dataset","text":"JuliaHub.dataset(dataset::DatasetReference; throw::Bool=true, [auth::Authentication]) -> Dataset\n\nLooks up a dataset based on the dataset reference dataset. Returns the Dataset object corresponding to dataset_name, or throws a InvalidRequestError if the dataset can not be found (if throw=false is passed, returns nothing instead).\n\nBy passing a Dataset object as dataset, this can be used to update the Dataset object.\n\njulia> dataset = JuliaHub.dataset(\"example-dataset\")\nDataset: example-dataset (Blob)\n owner: username\n description: An example dataset\n versions: 2\n size: 388 bytes\n tags: tag1, tag2\n\njulia> JuliaHub.dataset(dataset)\nDataset: example-dataset (Blob)\n owner: username\n description: An example dataset\n versions: 2\n size: 388 bytes\n tags: tag1, tag2\n\nIf the specifed username is not the currently authenticated user, the dataset must be shared with the currently authenticated user (i.e. contained in datasets(; shared=true)).\n\nnote: Note\nThis will call datasets every time, which might become a problem if you are processing a large number of datasets. In that case, you should call datasets and process the returned list yourself.\n\nwarning: Non-dynamic dataset objects\nDataset objects represents the dataset metadata when the Julia object was created (e.g. with dataset), and are not automatically kept up to date. To refresh the dataset metadata, you can pass an existing Dataset object to JuliaHub.dataset or project_dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/datasets/#JuliaHub.download_dataset","page":"Datasets","title":"JuliaHub.download_dataset","text":"download_dataset(\n    dataset::DatasetReference, local_path::AbstractString;\n    replace::Bool = false, [version::Integer],\n    [quiet::Bool = false], [auth::Authentication]\n) -> String\n\nDownloads the dataset specified by the dataset reference dataset to local_path (which must not exist, unless replace = true), returning the absolute path to the downloaded file or directory. If the dataset is a Blob, then the created local_path will be a file, and if the dataset is a BlobTree the local_path will be a directory.\n\nBy default, it downloads the latest version, but an older version can be downloaded by specifying the version keyword argument. Caution: you should never assume that the index of the .versions property of Dataset matches the version number â€“ always explicitly use the .id propert of the DatasetVersion object.\n\nThe function also prints download progress to standard output. This can be disabled by setting quiet=true. Any error output from the download is still printed.\n\nwarning: Warning\nSetting replace = true will recursively erase any existing data at local_path before replacing it with the dataset contents.\n\n\n\n\n\n","category":"function"},{"location":"reference/datasets/#JuliaHub.upload_dataset","page":"Datasets","title":"JuliaHub.upload_dataset","text":"JuliaHub.upload_dataset(dataset::DatasetReference, local_path; [auth,] kwargs...) -> Dataset\n\nUploads a new dataset or a new version of an existing dataset, with the dataset specified by the dataset reference dataset. The dataset type is determined from the local path (Blob if a file, BlobTree if a directory). If a Dataset object is passed, it attempts to update that dataset. Returns an updated Dataset object.\n\nThe following keyword arguments can be used to control the exact behavior of the function:\n\ncreate :: Bool (default: true): Create the dataset, if it already does not exist.\nupdate :: Bool (default: false): Upload the data as a new dataset version, if the dataset exists.\nreplace :: Bool (default: false): If a dataset exists, delete all existing data and create a new dataset with the same name instead. Excludes update = true, and only creates a completely new dataset if create=true as well.\n\nIn addition, the following keyword arguments can be passed to set or updated the dataset metadata when uploading:\n\ndescription: description of the dataset (a string)\ntags: an iterable of strings of all the tags of the dataset\nvisibility: a string with possible values public or private\nlicense: a valid SPDX license identifier (as a string or in a (:spdx, licence_identifier) tuple), or a tuple (:fulltext, license_text), where license_text is the full text string of a custom license\ngroups: an iterable of valid group names\n\ncompat: JuliaHub.jl v0.1.12\nThe license = (:fulltext, ...) form requires v0.1.12, and license = (:text, ...) is deprecated since that version.\n\nIf a dataset already exists, then these fields are updated as if update_dataset was called.\n\nThe function will throw an ArgumentError for invalid argument combinations.\n\nUse the progress keyword argument to suppress upload progress from being printed.\n\nnote: Note\nPresently, it is only possible to upload datasets for the currently authenticated user.\n\n\n\n\n\n","category":"function"},{"location":"reference/datasets/#JuliaHub.update_dataset","page":"Datasets","title":"JuliaHub.update_dataset","text":"JuliaHub.update_dataset(dataset::DatasetReference; kwargs..., [auth]) -> Dataset\n\nUpdates the metadata of the dataset specified by the dataset reference dataset, as according to the keyword arguments keyword arguments. If the keywords are omitted, the metadata corresponding to it remains unchanged. Returns the Dataset object corresponding to the updated dataset.\n\nThe supported keywords are:\n\ndescription: description of the dataset (a string)\ntags: an iterable of strings of all the tags of the dataset\nvisibility: a string with possible values public or private\nlicense: a valid SPDX license identifier (as a string or in a (:spdx, licence_identifier) tuple), or a tuple (:fulltext, license_text), where license_text is the full text string of a custom license\ngroups: an iterable of valid group names\n\ncompat: JuliaHub.jl v0.1.12\nThe license = (:fulltext, ...) form requires v0.1.12, and license = (:text, ...) is deprecated since that version.\n\nFor example, to add a new tag to a dataset:\n\ndataset = JuliaHub.dataset(\"my_dataset\")\nJuliaHub.update(dataset; tags = [dataset.tags..., \"newtag\"])\n\nnote: Note\nPresently, it is only possible to update datasets for the currently authenticated user.\n\n\n\n\n\n","category":"function"},{"location":"reference/datasets/#JuliaHub.delete_dataset","page":"Datasets","title":"JuliaHub.delete_dataset","text":"JuliaHub.delete_dataset(dataset::DatasetReference; force::Bool=false, [auth::Authentication]) -> Nothing\n\nDelete the dataset specified by the dataset reference dataset. Will return nothing if the delete was successful, or throws an error if it was not.\n\nNormally, when the dataset to be deleted does not exist, the function throws an error. This can be overridden by setting force = true.\n\njulia> JuliaHub.datasets()\n2-element Vector{JuliaHub.Dataset}:\n JuliaHub.dataset((\"username\", \"example-dataset\"))\n JuliaHub.dataset((\"username\", \"blobtree\"))\n\njulia> JuliaHub.delete_dataset(\"example-dataset\")\n\njulia> JuliaHub.datasets()\n1-element Vector{JuliaHub.Dataset}:\n JuliaHub.dataset((\"username\", \"blobtree\"))\n\nnote: Note\nPresently, it is only possible to delete datasets for the currently authenticated user.\n\n\n\n\n\n","category":"function"},{"location":"reference/datasets/#JuliaHub.DatasetProjectLink","page":"Datasets","title":"JuliaHub.DatasetProjectLink","text":"struct DatasetProjectLink\n\nHolds the project-dataset link metadata for datasets that were accessed via a project (e.g. when using project_datasets).\n\n.uuid :: UUID: the UUID of the project\n.is_writable :: Bool: whether the user has write access to the dataset via the this project\n\nSee also: project_dataset, project_datasets, upload_project_dataset.\n\ncompat: No public constructors\nObjects of this type should not be constructed explicitly. The contructor methods are not considered to be part of the public API.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#getting-started","page":"Getting Started","title":"Getting Started with JuliaHub.jl","text":"This tutorial walks you through the basic operations you can do with JuliaHub.jl, from installation to submitting simple jobs and working with datasets. If you are unfamiliar with JuliaHub.jl, this is a good place to get started.\n\nIf you already know what you wish to achieve with JuliaHub.jl, you can also skip this and jump directly into one of the more detailed how-to guides.\n\nIn particular, the tutorial will show\n\nHow to install JuliaHub.jl and connect it to a JuliaHub instance.\nHow to create, access and update a simple dataset.\nHow to submit a simple job.","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"JuliaHub.jl is a registered Julia package and can be installed using Julia's package manager. You can access the Julia package manager REPL mode by pressing ], and you can install JuliaHub.jl with\n\npkg> add JuliaHub\n\nAlternatively, you can use the Pkg standard library functions to install it.\n\nimport Pkg\nPkg.add(\"JuliaHub\")\n\nOnce it is installed, simply use import or using to load JuliaHub.jl into your current Julia session.\n\njulia> using JuliaHub\n\nnote: No exported names\nJuliaHub.jl does not have any exported names, so doing using JuliaHub does not introduce any functions or types in Main. Instead, JuliaHub.jl functions are designed to be used by prefixing them with JuliaHub. (e.g. JuliaHub.authenticate(...) or JuliaHub.submit_job(...))That said, there is nothing stopping you from explicitly bringing some names into your current scope, by doing e.g. using JuliaHub: submit_job, if you so wish!","category":"section"},{"location":"getting-started/#Authentication","page":"Getting Started","title":"Authentication","text":"In order to communicate with a JuliaHub instance, you need a valid authentication token. If you are working in a JuliaHub Cloud IDE, you actually do not need to do anything to be authenticated, as the authentication tokens are automatically set up in the cloud environment. To verify this, you can still call authenticate, which should load the pre-configured token.\n\nJuliaHub.authenticate()\n\nIf you are working on a local computer, the easiest way to get started is to pass the URL of the JuliaHub instance to authenticate. Unless you have authenticated before, this will initiate an interactive browser-based authentication.\n\njulia> JuliaHub.authenticate(\"juliahub.com\")\nAuthentication required: please authenticate in browser.\nThe authentication page should open in your browser automatically, but you may need to switch to the opened window or tab. If the authentication page is not automatically opened, you can authenticate by manually opening the following URL: ...\n\nOnce you have completed the steps in the browser, the function should return a valid authentication token.\n\nThe authenticate function returns an Authentication object, which hold the authentication token. In principle, you can pass these objects directly to JuliaHub.jl function via the auth keyword argument. However, in practice, this is usually not needed, because JuliaHub.jl also remembers the last authentication in the Julia session in a global variable. You can see the current globally stored authentication token with current_authentication.\n\nJuliaHub.current_authentication()\n\nnote: Authentication guide\nThere is more to authentication than this, including its relationship to the Julia package server and JULIA_PKG_SERVER environment variable. See the Authentication how-to if you want to learn more.","category":"section"},{"location":"getting-started/#Creating-and-accessing-datasets","page":"Getting Started","title":"Creating & accessing datasets","text":"JuliaHub.jl allows you to create, access, and update the datasets that are hosted on JuliaHub. This section shows some of the basic operations you can perform with datasets.\n\nThe datasets function allows you to list the datasets you have. Optionally, you can also make it show any other datasets you have access to.\n\nJuliaHub.datasets()\n\nUnless you have created datasets in the web UI or in the IDE, this list will likely be empty currently. To fix that, let us upload a simple dataset using JuliaHub.jl.\n\nJust as an example, we'll generate a simple 5-by-5 matrix, and save it in a file using the using the DelimitedFiles standard library.\n\nusing DelimitedFiles\nmat = [i^2 + j^2 for i=1:5, j=1:5]\nwritedlm(\"matrix.dat\", mat)\n\nNow that the matrix has been serialized into a text file on the disk, we can upload that file to JuliaHub with upload_dataset.\n\nJuliaHub.upload_dataset(\"tutorial-matrix\", \"matrix.dat\")\n\nwarning: Existing dataset\nIf you already happen to have a dataset with the same name, the upload_dataset call will fail. It is designed to be safe by default. However, you can pass update=true or replace=true to either upload your file as a new version of the dataset, or to delete all existing versions and upload a brand new version.\n\nIf we now call datasets, it should show up in the list of datasets.\n\nJuliaHub.datasets()\n\nTo see more details about the dataset, you can index into the array returned by datasets. Alternatively, you can also use the dataset function to pick out a single dataset by its name.\n\nJuliaHub.dataset(\"tutorial-matrix\")\n\nJuliaHub datasets also support basic metadata, such as tags and a description field. You could set it directly in the upload_dataset function, but we did not. But that is fine, since we can use update_dataset to update the metadata at any time.\n\nJuliaHub.update_dataset(\"tutorial-matrix\", description=\"An i^2 + j^2 matrix\")\n\nThe function also immediately queries JuliaHub for the updated dataset metadata by internally calling JuliaHub.dataset(\"tutorial-matrix\").\n\nFinally, JuliaHub.jl also allows you to download the datasets you have with the download_dataset function. We can also imagine doing this on a different computer or in a JuliaHub job.\n\nJuliaHub.download_dataset(\"tutorial-matrix\", \"matrix-downloaded.dat\")\n\nThis downloads the dataset into a local file, after which you can e.g. read it back into Julia and do operations on it.\n\nmat = readdlm(\"matrix-downloaded.dat\", '\\t', Int)\nsum(mat)\n\ntip: Directories as datasets\nWhile this demo uploaded a single file as a dataset, JuliaHub also supports uploading whole directories as a single dataset. For that, you can simply point upload_dataset to a directory, rather than a file. See the datasets how-to for more information on how to work with datasets.","category":"section"},{"location":"getting-started/#Submitting-a-job","page":"Getting Started","title":"Submitting a job","text":"JuliaHub.jl allows for an easy programmatic submission of JuliaHub jobs. In this example, we submit a simple script that downloads the dataset from the previous step, does a simple calculations and then upload the result. We then access the result locally with JuliaHub.jl.\n\nFirst, we need to specify the code that we want to run in the job. There are a few options for this, but in this example we use the @script_str string macro to construct a script-type computation, that simply runs the code snippet we specify.\n\nThe following script will access the dataset, calculates the sum of all the elements, and stores the value in the job results. You will be able to access the contents of RESULTS in both the web UI, but also via JuliaHub.jl.\n\ns = JuliaHub.script\"\"\"\nusing JuliaHub, DelimitedFiles\n@info JuliaHub.authenticate()\nJuliaHub.download_dataset(\"tutorial-matrix\", \"matrix-downloaded.dat\")\nmat = readdlm(\"matrix-downloaded.dat\", '\\t', Int)\nmat_sum = @show sum(mat)\nENV[\"RESULTS\"] = string(mat_sum)\n\"\"\"\n\nnote: Job environment\nIn most cases, you also submit a Julia package environment (i.e. Project.toml and Manifest.toml files together with a job). That environment then gets instantiated before the user-provided code is run.The script\"\" string macro, by default, attaches the currently active environment to the job. This means that any packages that you are currently using should also be available on the job (although only registered packages added as non-development dependencies will work). You can use Base.active_project() or pkg> status to see what environment is currently active.\n\nTo submit a job, you can simply call submit_job on it.\n\nj = JuliaHub.submit_job(s)\n\nThe submit_job function also allows you to specify configure how the job gets run, such as how many CPUs or how much memory it has available. By default, though, it runs your code on a single node, picking the smallest instance that is available.\n\nAt this point, if you go to the \"Jobs\" page web UI, you should see the job there. It may take a few moments to actually start running. You can also call job on the returned Job object to refresh the status of the job.\n\nj = JuliaHub.job(j)\n\nFinally, after the job has completed, if you refresh the Job it should reflect the final status of the job, and also give you access to the\n\nj = JuliaHub.job(j)\nj.results\n\nSee the jobs how-to guide for more details on the different options when it comes to job submission.","category":"section"},{"location":"getting-started/#Next-steps","page":"Getting Started","title":"Next steps","text":"This tutorial has hopefully given an overview of basic JuliaHub.jl usage. For more advanced usage, you may want to read through the more detailed how-to guides.\n\nPages = Main.PAGES_GUIDES\nDepth = 1:1\n\n","category":"section"},{"location":"release-notes/#Release-notes","page":"Release notes","title":"Release notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"section"},{"location":"release-notes/#Unreleased","page":"Release notes","title":"Unreleased","text":"","category":"section"},{"location":"release-notes/#Added","page":"Release notes","title":"Added","text":"Support for JuliaHub instances using MinIO as datasets storage backend. (#107, #112)","category":"section"},{"location":"release-notes/#Fixed","page":"Release notes","title":"Fixed","text":"The .message property should always be present in the log messages, but there are a few versions out there where it is sometimes omitted due to a backend bug. We default to an empty string in those cases. (#111)","category":"section"},{"location":"release-notes/#Version-[v0.1.15](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.15)-2025-08-29","page":"Release notes","title":"Version v0.1.15 - 2025-08-29","text":"","category":"section"},{"location":"release-notes/#Fixed-2","page":"Release notes","title":"Fixed","text":"Top-level .juliabundleignore files are now correctly handled when using JuliaHub.appbundle. (#99, #100)\nThe JuliaHub.upload_dataset now correctly throws a JuliaHubError on certain backend errors. (#103)","category":"section"},{"location":"release-notes/#Version-[v0.1.14](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.14)-2025-06-11","page":"Release notes","title":"Version v0.1.14 - 2025-06-11","text":"","category":"section"},{"location":"release-notes/#Added-2","page":"Release notes","title":"Added","text":"Support for displaying and submitting batch image options with tags when working with JuliaHub instances v6.10 and above. (#94)","category":"section"},{"location":"release-notes/#Experimental","page":"Release notes","title":"Experimental","text":"There is now experimental support for registering Julia packages in a JuliaHub package registry. (#96)","category":"section"},{"location":"release-notes/#Version-[v0.1.13](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.13)-2025-04-28","page":"Release notes","title":"Version v0.1.13 - 2025-04-28","text":"","category":"section"},{"location":"release-notes/#Fixed-3","page":"Release notes","title":"Fixed","text":"Setting JULIAHUB_PROJECT_UUID to an empty (or whitespace-only) string is now treated the same as unsetting it. (#92)","category":"section"},{"location":"release-notes/#Version-[v0.1.12](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.12)-2025-04-25","page":"Release notes","title":"Version v0.1.12 - 2025-04-25","text":"","category":"section"},{"location":"release-notes/#Added-3","page":"Release notes","title":"Added","text":"With JuliaHub instances v6.9 and above, JuliaHub.jl now supports project-dataset operations. (#15, #82)\nThis includes the following new features:\nAuthentication objects can now be associated with projects. If the JULIAHUB_PROJECT_UUID environment variable is set, JuliaHub.jl will pick it up automatically..\nThe project_dataset and project_datasets functions allow for listing datasets attached to a project.\nupload_project_dataset can be used to upload a new version of a dataset.\nAll the public API names are now correctly marked public in Julia 1.11 and above. (#83)","category":"section"},{"location":"release-notes/#Changed","page":"Release notes","title":"Changed","text":"The string repr of DatasetVersion (e.g. dataset.versions) is now valid Julia code. (#84)\nJuliaHub.authenticate will now fall back to force-authentication if the token in an existing auth.toml file is found to be invalid during authentication. (#86)","category":"section"},{"location":"release-notes/#Fixed-4","page":"Release notes","title":"Fixed","text":"The JuliaHub.update_dataset function now correctly accepts the license=(:fulltext, ...) argument. (#74)","category":"section"},{"location":"release-notes/#Version-[v0.1.11](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.11)-2024-06-27","page":"Release notes","title":"Version v0.1.11 - 2024-06-27","text":"","category":"section"},{"location":"release-notes/#Added-4","page":"Release notes","title":"Added","text":"The JuliaHub.authenticate function now supports a two-argument form, where you can pass the JuliaHub token in directly, bypassing interactive authentication. (#58)\nThe JuliaHub.submit_job function now allows submitting jobs that expose ports (via the expose argument). Related to that, the new JuliaHub.request function offers a simple interface for constructing authenticated HTTP.jl requests against the job, and the domain name of the job can be accessed via the new .hostname property of the Job object. (#14, #52)","category":"section"},{"location":"release-notes/#Version-[v0.1.10](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.10)-2024-05-31","page":"Release notes","title":"Version v0.1.10 - 2024-05-31","text":"","category":"section"},{"location":"release-notes/#Changed-2","page":"Release notes","title":"Changed","text":"When submitting an appbundle with the two-argument JuliaHub.appbundle(bundle_directory, codefile) method, JuliaHub.jl now ensures that @__DIR__ @__FILE, and include() in the user code now work correctly. There is a subtle behavior change due to this, where now the user script must be present within the uploaded appbundle tarball (previously it was possible to use a file that would get filtered out by .juliabundleignore). (#37, [#53])","category":"section"},{"location":"release-notes/#Version-[v0.1.9](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.9)-2024-03-13","page":"Release notes","title":"Version v0.1.9 - 2024-03-13","text":"","category":"section"},{"location":"release-notes/#Fixed-5","page":"Release notes","title":"Fixed","text":"JuliaHub.nodespec now correctly prioritizes the GPU, CPU, and memory counts, rather than the hourly price, when picking a \"smallest node for a given spec\". (#49)","category":"section"},{"location":"release-notes/#Version-[v0.1.8](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.8)-2024-02-21","page":"Release notes","title":"Version v0.1.8 - 2024-02-21","text":"","category":"section"},{"location":"release-notes/#Added-5","page":"Release notes","title":"Added","text":"The progress output printing in JuliaHub.upload_dataset can now be disabled by setting progress=false. (#48)","category":"section"},{"location":"release-notes/#Version-[v0.1.7](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.7)-2024-01-22","page":"Release notes","title":"Version v0.1.7 - 2024-01-22","text":"","category":"section"},{"location":"release-notes/#Fixed-6","page":"Release notes","title":"Fixed","text":"JuliaHub.datasets and JuliaHub.dataset now handle problematic backend responses more gracefully. (#46)","category":"section"},{"location":"release-notes/#Version-[v0.1.6](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.6)-2023-11-27","page":"Release notes","title":"Version v0.1.6 - 2023-11-27","text":"","category":"section"},{"location":"release-notes/#Fixed-7","page":"Release notes","title":"Fixed","text":"JuliaHub.appbundle, when it has to generate a Project.toml file, now correctly includes it in the appbundle tarball. (#44)\nJuliaHub.appbundle now works with relative paths such as \".\". (#44)","category":"section"},{"location":"release-notes/#Version-[v0.1.5](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.5)-2023-09-27","page":"Release notes","title":"Version v0.1.5 - 2023-09-27","text":"","category":"section"},{"location":"release-notes/#Added-6","page":"Release notes","title":"Added","text":"The job submission APIs now support jobs with no time limit, and also can be used to submit jobs that trigger system image builds. (#28)","category":"section"},{"location":"release-notes/#Fixed-8","page":"Release notes","title":"Fixed","text":"Fixed the submission of application-type jobs. (#31, #32, #33, #35)\nJuliaHub.applications() no longer throws a type error when the user has no registered and user applications. (#33)\nFixed the show(io, x) methods for ComputeConfig and NodeSpec. (#34)","category":"section"},{"location":"release-notes/#Version-[v0.1.4](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.4)-2023-08-21","page":"Release notes","title":"Version v0.1.4 - 2023-08-21","text":"","category":"section"},{"location":"release-notes/#Fixed-9","page":"Release notes","title":"Fixed","text":"upload_dataset and download_dataset no longer use the deprecated do-syntax to call the rclone binary. (#18)","category":"section"},{"location":"release-notes/#Version-[v0.1.3](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.3)-2023-07-17","page":"Release notes","title":"Version v0.1.3 - 2023-07-17","text":"","category":"section"},{"location":"release-notes/#Changed-3","page":"Release notes","title":"Changed","text":"The name keyword argument to submit_job has been deprecated and replaced with alias. (#13)","category":"section"},{"location":"release-notes/#Fixed-10","page":"Release notes","title":"Fixed","text":"extend_job now correctly handles the 200 but success: false response. (#13)\nAn assortment of small bugfixes revealed by JET. (#9) (#12)","category":"section"},{"location":"release-notes/#Tests","page":"Release notes","title":"Tests","text":"The test suite now runs successfully when the package is Pkg.added and the package files have only read-only permissions. (#11)","category":"section"},{"location":"release-notes/#Version-[v0.1.2](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.2)-2023-06-26","page":"Release notes","title":"Version v0.1.2 - 2023-06-26","text":"","category":"section"},{"location":"release-notes/#Fixed-11","page":"Release notes","title":"Fixed","text":"If TimeZones.jl fails to determine the system's timezone, JuliaHub.jl now gracefully falls back to UTC to represent dates and times. (#7)","category":"section"},{"location":"release-notes/#Version-[v0.1.1](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.1)-2023-06-24","page":"Release notes","title":"Version v0.1.1 - 2023-06-24","text":"","category":"section"},{"location":"release-notes/#Changed-4","page":"Release notes","title":"Changed","text":"The JuliaHub.download_job_file function now returns the path of the relevant local file. (#3)","category":"section"},{"location":"release-notes/#Fixed-12","page":"Release notes","title":"Fixed","text":"Jobs with files that have missing data are now handled gracefully by defaulting the .size property to 0 and .hash property to nothing. (#3)\nInformation about dataset versions can now be accessed via the the .versions property of a Dataset object. (#2)\nThe automatic backend API version detection is now more reliable in some edge cases. (#1)","category":"section"},{"location":"release-notes/#Version-[v0.1.0](https://github.com/JuliaComputing/JuliaHub.jl/releases/tag/v0.1.0)-2023-06-20","page":"Release notes","title":"Version v0.1.0 - 2023-06-20","text":"Initial package release.\n\n","category":"section"},{"location":"guides/jobs/#Jobs","page":"Jobs","title":"Jobs","text":"JuliaHub.jl can be used to both submit new jobs, and to inspect running or finished jobs.\n\nPages = [\"jobs.md\"]\nDepth = 2:10","category":"section"},{"location":"guides/jobs/#jobs-guide-batch","page":"Jobs","title":"Submitting batch jobs","text":"A common use case for this package is to programmatically submit Julia scripts as batch jobs to JuliaHub, to start non-interactive workloads. In a nutshell, these are Julia scripts, together with an optional Julia environment, that get executed on the allocated hardware.\n\nThe easiest way to start a batch job is to submit a single Julia script, which can optionally also include a Julia environment with the job. However, for more complex jobs, with multiple inputs files etc., appbundles are likely more suitable.","category":"section"},{"location":"guides/jobs/#jobs-batch-script","page":"Jobs","title":"Script jobs","text":"The simplest job one can submit is a humble Julia script, together with an optional Julia environment (i.e. Project.toml, Manifest.toml, and/or Artifacts.toml). These jobs can be created with the JuliaHub.@script_str string macro, for inline instantiation:\n\nJuliaHub.submit_job(\n    JuliaHub.script\"\"\"\n    @warn \"Hello World!\"\n    \"\"\",\n)\n\nAlternatively, they can be created with the script function, which can load the Julia code from a script file:\n\ncd(_temp_path) do # hide\nJuliaHub.submit_job(\n    JuliaHub.script(\"myscript.jl\"),\n)\nend # hide\n\nThe string macro also picks up the currently running environment (i.e. Project.toml, Manifest.toml, and Artifacts.toml files), which then gets instantiated on JuliaHub when the script is started. If necessary, this can be disabled by appending the noenv suffix to the string macro.\n\nJuliaHub.script\"\"\"\n@warn \"Hello World!\"\n\"\"\"noenv\n\nWith the script function, you can also specify a path to directory containing the Julia package environment, if necessary.\n\nIf an environment is passed with the job, it gets instantiated on the JuliaHub node, and the script is run in that environment. As such, any packages that are not available in the package registries or added via public Git URLs will not work. If that is the case, appbundles can be used instead to submit jobs that include private or local dependencies.","category":"section"},{"location":"guides/jobs/#jobs-batch-appbundles","page":"Jobs","title":"Appbundles","text":"A more advanced way of submitting a batch job is as an appbundle, which \"bundles up\" a whole directory and submits it together with the script. The Julia environment in the directory is also immediately added into the bundle.\n\nAn appbundle can be constructed with the appbundle function, which takes as arguments the path to the directory to be bundled up, and a script within that directory. This is meant to be used for project directories where you have your Julia environment in the top level of the directory or repository.\n\nFor example, suppose you have a script at the top level of your project directory, then you can submit a bundle as follows:\n\nimport JuliaHub # hide\n# We need to override the @__DIR__ here, because we actually construct a real appbundle # hide\nmacro __DIR__(); joinpath(dirname(dirname(pathof(JuliaHub))), \"test\", \"jobenvs\", \"job1\"); end # hide\nJuliaHub.submit_job(\n    JuliaHub.appbundle(@__DIR__, \"script.jl\"),\n    ncpu = 4, memory = 16,\n)\n\nThe bundler looks for a Julia environment (i.e. Project.toml, Manifest.toml, and/or Artifacts.toml files) at the root of the directory. If the environment does not exist (i.e. the files are missing), one is created. When the job starts on JuliaHub, this environment is instantiated.\n\nA key feature of the appbundle is that development dependencies of the environment (i.e. packages added with pkg> develop or Pkg.develop()) are also bundled up into the archive that gets submitted to JuliaHub (including any current, uncommitted changes). Registered packages are installed via the package manager via the standard environment instantiation, and their source code is not included in the bundle directly.\n\nWhen the JuliaHub job starts, the working directory is set to the root of the unpacked appbundle directory. This should be kept in mind especially when launching a script that is not at the root itself, and trying to open other files from the appbundle in that script (e.g. with open). You can still use @__DIR__ to load files relative to the script, and includes also work as expected (i.e. relative to the script file).\n\nFinally, a .juliabundleignore file can be used to exclude certain directories, by adding the relevant globs, similar to how .gitignore files work. In addition, .git directories are also automatically excluded from the bundle.","category":"section"},{"location":"guides/jobs/#Examining-job-configuration","page":"Jobs","title":"Examining job configuration","text":"The dryrun option to submit_job can be used to inspect the full job workload configuration that would be submitted to JuliaHub.\n\nimport JuliaHub # hide\nJuliaHub.submit_job(\n    JuliaHub.script\"\"\"\n    println(\"hello world\")\n    \"\"\",\n    ncpu = 4, memory = 8,\n    env = Dict(\"ARG\" => \"value\"),\n    dryrun = true\n)","category":"section"},{"location":"guides/jobs/#Query,-extend,-kill","page":"Jobs","title":"Query, extend, kill","text":"The package has function that can be used to interact with running and past jobs. The jobs function can be used to list jobs, returning an array of Job objects.\n\njs = JuliaHub.jobs(limit=3)\njs[1]\n\nIf you know the name of the job, you can also query the job directly with job.\n\njob = JuliaHub.job(\"jr-eezd3arpcj\")\njob.status\nJuliaHub.isdone(job)\n\nSimilarly, the kill_job function can be used to stop a running job, and the extend_job function can be used to extend the job's time limit.","category":"section"},{"location":"guides/jobs/#Waiting-on-jobs","page":"Jobs","title":"Waiting on jobs","text":"A common pattern in a script is to submit one or more jobs, and then wait until the jobs complete, to then process their outputs. isdone can be used to see if a job has completed.\n\njob = JuliaHub.job(\"jr-novcmdtiz6\")\nJuliaHub.isdone(job)\n\nThe wait_job function also provides a convenient way for a script to wait for a job to finish.\n\njob = JuliaHub.wait_job(\"jr-novcmdtiz6\")\nJuliaHub.isdone(job)","category":"section"},{"location":"guides/jobs/#Accessing-job-outputs","page":"Jobs","title":"Accessing job outputs","text":"There are two ways a JuliaHub job can store outputs that are directly related to a specific job[1]:\n\nSmall, simple outputs can be stored by setting the ENV[\"RESULTS\"] environment variable. Conventionally, this is often set to a JSON object, and will act as a dictionary of key value pairs.\nFiles or directories can be uploaded by setting the ENV[\"RESULTS_FILE\"] to a local file path on the job. Note that directories are combined into a single tarball when uploaded.\n\n[1]: You can also e.g. upload datasets etc. But in that case the resulting data is not, strictly speaking, related to a specific job.\n\nThe values set via the RESULTS environment variable can be accessed with the .results field of a Job object:\n\njob.results\n\nAs the .results string is often a JSON object, you can use the the JSON.jl or JSON3.jl packages to easily parse it. For example\n\nimport JSON\nJSON.parse(job.results)\n\nWhen it comes to job result files, they can all be accessed via the .files field.\n\njob.files\n\nThe job_files function can be used to filter down to specific file types.\n\nJuliaHub.job_files(job, :result)\n\nAnd if you know the name of the file, you can also use the job_files to get the specific JobFile object for a particular file directly.\n\njobfile = JuliaHub.job_file(job, :result, \"outdir.tar.gz\")\n\nTo actually fetch the contents of a file, you can use the download_job_file function on the JobFile objects.","category":"section"},{"location":"guides/jobs/#jobs-batch-expose-port","page":"Jobs","title":"Opening ports on batch jobs","text":"If supported for a given product and user, you can expose a single port on the job serving a HTTP server, to do HTTP requests to the job from the outside. This could be used to run \"interactive\" jobs that respond to user inputs, or to poll the job for data.\n\nFor example, the following job would run a simple Oxygen.jl-based server that exposes a simple API at the / path.\n\nimport JuliaHub # hide\njob = JuliaHub.submit_job(\n    JuliaHub.script\"\"\"\n    using Oxygen, HTTP\n    # Environment variable name `PORT` was used in older JuliaHub environments\n    # and has been replaced with `JULIAHUB_APP_PORT` in newer environments \n    PORT = parse(Int, get(ENV, \"JULIAHUB_APP_PORT\", get(ENV, \"PORT\", \"\")))\n    @get \"/\" function(req::HTTP.Request)\n        return \"success\"\n    end\n    serve(; host=\"0.0.0.0\", port = PORT)\n    \"\"\",\n    expose = 8080,\n)\n\nNote that, unlike a usual batch job, this job has a .hostname property, that will point to the DNS hostname that can be used to access the server exposed by the job (see also the relevant reference section).\n\nOnce the job has started and the Oxygen-based server has started serving the page, you can perform HTTP.jl requests against the job with the JuliaHub.request function, which is thin wrapper around the HTTP.request function that sets up the necessary authentication headers and constructs the full URL.\n\nJuliaHub.request(job, \"GET\", \"/\")\n\nnote: 502 Bad Gateway\nWhen the job is starting up or if the HTTP server in the job is not running, you can expect a 502 Bad Gateway HTTP response from the job domain.\n\ntip: HTML page\nIf the server can serve a HTML page, then you can also access the job in the browser. The web UI will also have a \"Connect\" link, like for other interactive applications.\n\nnote: Pricing\nJobs that expose ports may be priced differently per hour than batch jobs that do not open ports.\n\n","category":"section"},{"location":"reference/exceptions/#Exceptions","page":"Exceptions","title":"Exceptions","text":"JuliaHub.jl is designed in a way that the only errors it should throw under normal circumstances are subtypes of JuliaHubException (in addition to standard ArgumentErrors and MethodErrors etc. from invalid function calls). Any unhandled errors from JuliaHub.jl or its dependencies should be considered a bug.\n\ntip: Debugging JuliaHub.jl issues\nYou can also enable debug logging for JuliaHub, which will make JuliaHub.jl print out additional debug messages, by setting the JULIA_DEBUG environment variable:ENV[\"JULIA_DEBUG\"]=\"JuliaHub\"","category":"section"},{"location":"reference/exceptions/#Index","page":"Exceptions","title":"Index","text":"Pages = [\"exceptions.md\"]\n\n","category":"section"},{"location":"reference/exceptions/#JuliaHub.JuliaHubException","page":"Exceptions","title":"JuliaHub.JuliaHubException","text":"abstract type JuliaHubException <: Exception\n\nAbstract supertype of all JuliaHub.jl exception types.\n\n\n\n\n\n","category":"type"},{"location":"reference/exceptions/#JuliaHub.AuthenticationError","page":"Exceptions","title":"JuliaHub.AuthenticationError","text":"struct AuthenticationError <: JuliaHubException\n\nException thrown if the authentication fails. The .msg fields contains a human-readable error message.\n\n\n\n\n\n","category":"type"},{"location":"reference/exceptions/#JuliaHub.InvalidAuthentication","page":"Exceptions","title":"JuliaHub.InvalidAuthentication","text":"struct InvalidAuthentication <: JuliaHubException\n\nThis exception is thrown if the authentication token is invalid or has expired. Re-authenticating with JuliaHub.authenticate should generally be sufficient to resolve the issue.\n\n\n\n\n\n","category":"type"},{"location":"reference/exceptions/#JuliaHub.InvalidRequestError","page":"Exceptions","title":"JuliaHub.InvalidRequestError","text":"struct InvalidRequestError <: JuliaHubException\n\nAn exception thrown if the request was rejected by the backend due to request parameters that are inconsistent with the backend state. The .msg field contains the error message.\n\n\n\n\n\n","category":"type"},{"location":"reference/exceptions/#JuliaHub.JuliaHubConnectionError","page":"Exceptions","title":"JuliaHub.JuliaHubConnectionError","text":"struct JuliaHubConnectionError <: JuliaHubException\n\nAn exception thrown if there is a communication error with JuliaHub.\n\nThe .msg field contains the error message. If there is an underlying exception, it is stored in the .exception field.\n\n\n\n\n\n","category":"type"},{"location":"reference/exceptions/#JuliaHub.JuliaHubError","page":"Exceptions","title":"JuliaHub.JuliaHubError","text":"struct JuliaHubError <: JuliaHubException\n\nAn exception thrown if there is an unexpected response from or backend failure in JuliaHub.\n\nThe .msg field contains the error message. If there is an underlying exception, it is stored in the .exception field.\n\n\n\n\n\n","category":"type"},{"location":"reference/exceptions/#JuliaHub.PermissionError","page":"Exceptions","title":"JuliaHub.PermissionError","text":"struct PermissionError <: JuliaHubException\n\nThrown if the currently authenticated user does not have the necessary permissions to perform the operation. The .msg field contains the error message, and .response may contain the raw server response.\n\n\n\n\n\n","category":"type"},{"location":"reference/exceptions/#JuliaHub.ProjectNotSetError","page":"Exceptions","title":"JuliaHub.ProjectNotSetError","text":"struct ProjectNotSetError <: JuliaHubException\n\nException thrown by a project-related operation that requires a project to be specified, but neither an explicit project reference was provided, nor was the project set for the authentication object.\n\n\n\n\n\n","category":"type"},{"location":"reference/exceptions/#JuliaHub.InvalidJuliaHubVersion","page":"Exceptions","title":"JuliaHub.InvalidJuliaHubVersion","text":"struct InvalidJuliaHubVersion <: JuliaHubException\n\nThrown if the requested operation is not supported by the JuliaHub instance. .msg contains a more detailed error message.\n\ntip: Tip\nThis generally means that the functionality you are attempting to use requires a newer JuliaHub version.\n\n\n\n\n\n","category":"type"},{"location":"guides/authentication/#guide-authentication","page":"Authentication","title":"Authentication","text":"In order to talk to a JuliaHub instance, you must authenticate with your user account, and have an authentication token. JuliaHub.jl aims to make it as easy and painless as possible to manage your authentication tokens.","category":"section"},{"location":"guides/authentication/#Overview","page":"Authentication","title":"Overview","text":"To use this package to authenticate in your current Julia session, you can call the authenticate function. It will return an Authentication object, containing the token.\n\nIn principle, nearly every function here takes an (optional) auth keyword argument, that should be passed an Authentication object. However, this is usually not needed in practice, since JuliaHub.jl remembers your last authentication, and uses that as the default value for auth. Additionally, if there is no active authentication, calling any function that requires authentication will try to automatically authenticate (and may also trigger an interactive authentication). You can access the currently active authentication object with current_authentication.\n\nIn order for authenticate to work, you must specify which JuliaHub instance to authenticate against (e.g. juliahub.com). There are two options for this:\n\nYou can configure the Julia package server to point to the JuliaHub instance by explicitly setting the JULIA_PKG_SERVER environment variable. See Local environments below to for more information on how to do it in local environments. In JuliaHub jobs, however, it is automatically set.\nYou can directly pass the JuliaHub instance URL to authenticate, e.g. JuliaHub.authenticate(\"juliahub.com\").\n\nIf a valid token for the JuliaHub instance exists on the disk, authenticate will use that directly. Otherwise it will attempt an interactive, browser-based authentication against the Julia instance. For the latter, under the hood, it uses the PkgAuthentication package to perform the interactive authentication\n\ntip: Authentication token storage\nJuliaHub (or, more generally, package server) tokens are stored in the ~/.julia/servers/ directory. Inspecting the auth.toml files, or deleting them and re-authenticating may help if you are having unexpected issues with authentication.Note that this applies mainly when running JuliaHub.jl on your local computer. In JuliaHub cloud IDEs and jobs, the authentication token is actively managed by JuliaHub, and tampering with it may lead to other issues.","category":"section"},{"location":"guides/authentication/#JuliaHub-cloud-environments","page":"Authentication","title":"JuliaHub cloud environments","text":"When working with JuliaHub.jl in JuliaHub cloud environment, such as in JuliaHub Cloud IDEs or in JuliaHub jobs, you generally do not have to worry about authentication. The JULIA_PKG_SERVER should always be correctly set up, and the auth.toml file will also be present and up-to-date. This means that authenticate should automatically be able to authenticate your session, and you should never be prompted for interactive authentication.\n\nThis also extends to JuliaHub Projects support â€“- if an IDE has been launched withing the context of a project, the environment will have the JULIAHUB_PROJECT_UUID environment set, and the authentication object will be automatically linked to the correct project.\n\ntip: No need to authenticate()\nAs in a JuliaHub environment everything is already set up and pointing to the correct server, you do not need to call authenticate yourself, nor set up JULIA_PKG_SERVER. You should be able to start using JuliaHub.jl functions right away.However, in JuliaHub jobs, you may still want to log the Authentication object in the job logs. You can use something like this at the top of your script:@info \"JuliaHub authentication token\" JuliaHub.authenticate()","category":"section"},{"location":"guides/authentication/#Local-environments","page":"Authentication","title":"Local environments","text":"When using JuliaHub.jl outside of JuliaHub (e.g. on your local laptop), you must explicitly configure the Julia package server, or pass the JuliaHub URL to authenticate.\n\nThe Julia package server can be configured via the JULIA_PKG_SERVER environment variable, and there are a few options for this. In a live Julia session, you can simply set it via ENV, e.g.\n\nENV[\"JULIA_PKG_SERVER\"] = \"juliahub.com\"\n\nYou can also do it this way in the Julia startup.jl script.\n\nAlternatively, on an UNIX-y system, you can set it in the shell or a script with e.g.\n\nexport JULIA_PKG_SERVER=juliahub.com\n\nIf you're exclusively using the VS Code editor with the Julia extension, you can configure the package server in the UI directly, and it will apply to any REPLs you open in VS Code.\n\n(Image: Julia: Package Server option in Julia VS Code extension)\n\nWhen running JuliaHub.jl on your local computer for the first time, or when you have not used JuliaHub.jl in a while, you will likely see something like:\n\njulia> using JuliaHub\n\njulia> JuliaHub.authenticate()\nAuthentication required: please authenticate in browser.\nThe authentication page should open in your browser automatically, but you may need to switch to the opened window or tab. If the authentication page is not automatically opened, you can authenticate by manually opening the following URL: ...\n\nOnce you perform the browser-based authentication, the local auth.toml file gets updated, and JuliaHub.jl will be able to talk to the JuliaHub instance.\n\nnote: JULIA_PKG_SERVER\nSetting JULIA_PKG_SERVER will also make the Julia package manager operations use the JuliaHub instance for Pkg operations. This is necessary for accessing packages on the private registries only accessible via JuliaHub. But it also means that you must have a valid JuliaHub authentication token in order to pull packages from the General registry.\n\nnote: Enterprise JuliaHub instances\nEnterprise users generally have their own JuliaHub instance hosted under a different domain. In those cases, the recommended workflow is to globally set the JULIA_PKG_SERVER variable to point to the enterprise instance. This has the following benefits:JuliaHub.jl will, by default, authenticate with the server defined by JULIA_PKG_SERVER, opening a browser window if needed to acquire the token.\nAll package manager operations (i.e. pkg> or Pkg.*) will be routed through your enterprise JuliaHub instances as well. This is most useful if you need access to packages that are available in your company's private registries.Note: the same authentication token is used for package operations and JuliaHub operations.\n\n","category":"section"},{"location":"internal/#Internal","page":"Internal","title":"Internal","text":"","category":"section"},{"location":"internal/#_PackageBundler","page":"Internal","title":"_PackageBundler","text":"","category":"section"},{"location":"internal/#Index","page":"Internal","title":"Index","text":"Pages = [\"internal.md\"]\n\n","category":"section"},{"location":"internal/#JuliaHub._PackageBundler.bundle","page":"Internal","title":"JuliaHub._PackageBundler.bundle","text":"bundle(dir; output = \"\",  force=false, allownoenv=false, verbose = true) -> String\n\nCreates a .tar file with the contents of dir as well as any packages that are either tracked by path (developed) outside dir or packages that are not tracked by the PkgServer. Artifacts are also bundled. The bundled packages and artifacts go into a .bundled/depot directory and is set up like a depot and can thus be made available by adding it to DEPOT_PATH.\n\n.git and globs listed in .juliabundleignore are excluded form the bundle.\n\nReturns the hex-encoded SHA256 of the Manifest.toml file that is packed into the appbundle. The return value is used when requesting a sysimage build, in which case we have to pass the manifest's hash with the submit request.\n\n\n\n\n\n","category":"function"},{"location":"internal/#JuliaHub._PackageBundler.path_filterer","page":"Internal","title":"JuliaHub._PackageBundler.path_filterer","text":"path_filterer(top)\n\nReturns a function that takes a file or directory path and checks whether that is excluded by the nearest .juliabundleignore file. The function will also ignore any .git files and directories.\n\nThe top argument specifies the highest directory up the tree that will be searched for the .juliabundleignore file.\n\nThe function will return false for any excluded files and true otherwise, and can be used as a predicate for filtering files that should be bundled.\n\n\n\n\n\n","category":"function"},{"location":"reference/projects/#Projects","page":"Projects","title":"Projects","text":"These APIs allow you to interact with datasets that have been attached to projects.\n\nproject_datasets and project_dataset let you list and access datasets linked to a project\nupload_project_dataset allows uploading new versions of project-linked datasets","category":"section"},{"location":"reference/projects/#Automatic-project-authentication","page":"Projects","title":"Automatic project authentication","text":"The Authentication object can be associated with a default project UUID, which will then be used to for all project operations, unless an explicit project gets passed to override the default.\n\nImportantly, JuliaHub.authenticate will automatically pick up the the JuliaHub project UUID from the JULIAHUB_PROJECT_UUID environment variable. This means in JuliaHub cloud jobs and IDEs, it is not necessary to manually set the project, and JuliaHub.jl will automatically. However, you can opt-out of this behavior by explicitly passing a project=nothing to JuliaHub.authenticate.\n\nYou can always verify that your operations are running in the context of the correct project by checking the Authentication object, e.g. via current_authentication:\n\njulia> JuliaHub.current_authentication()\nJuliaHub.Authentication(\"https://juliahub.com\", \"username\", *****; project_id = \"cd6c9ee3-d15f-414f-a762-7e1d3faed835\")","category":"section"},{"location":"reference/projects/#Reference","page":"Projects","title":"Reference","text":"","category":"section"},{"location":"reference/projects/#Index","page":"Projects","title":"Index","text":"Pages = [\"project_datasets.md\"]\n\n","category":"section"},{"location":"reference/projects/#JuliaHub.project_datasets","page":"Projects","title":"JuliaHub.project_datasets","text":"JuliaHub.project_datasets([project::ProjectReference]; [auth::Authentication]) -> Vector{Dataset}\n\nReturns the list of datasets attached to the project, as a list of Dataset objects. If the project is not explicitly specified, it uses the project of the authentication object.\n\nMay throw a ProjectNotSetError. Will throw an [InvalidRequestError] if the currently authenticated user does not have access to the project or the project does not exists.\n\njulia> JuliaHub.current_authentication()\nJuliaHub.Authentication(\"https://juliahub.com\", \"username\", *****; project_id = \"cd6c9ee3-d15f-414f-a762-7e1d3faed835\")\n\njulia> JuliaHub.project_datasets()\n3-element Vector{JuliaHub.Dataset}:\n JuliaHub.project_dataset((\"username\", \"example-dataset\"); project=\"cd6c9ee3-d15f-414f-a762-7e1d3faed835\")\n JuliaHub.project_dataset((\"anotheruser\", \"publicdataset\"); project=\"cd6c9ee3-d15f-414f-a762-7e1d3faed835\")\n JuliaHub.project_dataset((\"username\", \"blobtree/example\"); project=\"cd6c9ee3-d15f-414f-a762-7e1d3faed835\")\n\n\n\n\n\n","category":"function"},{"location":"reference/projects/#JuliaHub.project_dataset","page":"Projects","title":"JuliaHub.project_dataset","text":"JuliaHub.project_dataset(dataset::DatasetReference; [project::ProjectReference], [auth]) -> Dataset\n\nLooks up the specified dataset among the datasets attached to the project, returning a Dataset object, or throwing an InvalidRequestError if the project does not have such dataset attached.\n\njulia> JuliaHub.project_dataset((\"username\", \"blobtree/example\"))\nDataset: blobtree/example (BlobTree)\n owner: username\n description: An example dataset\n versions: 1\n size: 57 bytes\n tags: tag1, tag2\n project: cd6c9ee3-d15f-414f-a762-7e1d3faed835 (not writable)\n\nnote: Implicit dataset owner\nWhen passing just the dataset name for dataset (i.e. <: AbstractString), then, just like for the non-project JuliaHub.dataset function, it is assumed that the owner of the dataset should be the currently authenticated user.However, a project may have multiple datasets with the same name attached to it (if they are owned by different users). The best practice when accessing datasets in the context of projects is to fully specify their name (i.e. also include the username).\n\nwarning: Non-dynamic dataset objects\nDataset objects represents the dataset metadata when the Julia object was created (e.g. with dataset), and are not automatically kept up to date. To refresh the dataset metadata, you can pass an existing Dataset object to JuliaHub.dataset or project_dataset.\n\n\n\n\n\n","category":"function"},{"location":"reference/projects/#JuliaHub.upload_project_dataset","page":"Projects","title":"JuliaHub.upload_project_dataset","text":"JuliaHub.upload_project_dataset(\n    dataset::DatasetReference, local_path;\n    progress=true,\n    [project::ProjectReference],\n    [auth::Authentication],\n) -> Dataset\n\nUploads a new version of a project-linked dataset.\n\nBy default, the new dataset version will be associated with the project of the current authentication session (if any), but this can be overridden by passing project.\n\nnote: Permissions\nNote that in order for this to work, you need to have edit rights on the projects and the dataset needs to have been marked writable by the dataset owner. However, unlike for normal datasets uploads (with upload_dataset), you do not need to be the dataset owner to upload new versions.\n\ntip: Tip\nThe function call is functionally equivalent to the following upload_dataset callJuliaHub.upload_dataset(\n    dataset, local_path;\n    create=false, update=true, replace=false,\n)except that the upload is associated with a project.\n\n\n\n\n\n","category":"function"},{"location":"reference/projects/#JuliaHub.ProjectReference","page":"Projects","title":"JuliaHub.ProjectReference","text":"const ProjectReference :: Type\n\nType constraint on the argument that specifies the project in projects-related APIs that (e.g. project_datasets).\n\nPresently, you can specify the project by directly passing the project UUID. The UUID should be either a string (<: AbstractString) or an UUIDs.UUID object.\n\n\n\n\n\n","category":"type"},{"location":"reference/jobs/#job-apis","page":"Jobs","title":"Jobs","text":"JuliaHub.jl provides various methods to inspect and interact jobs that have been submitted to JuliaHub. It is also possible to get access to job outputs programmatically.","category":"section"},{"location":"reference/jobs/#Job-status-states","page":"Jobs","title":"Job status states","text":"A job will be in various \"states\" during its execution, and its current state can be inspected via the [.status] field.\n\nThe following diagram illustrates the possible states a job can be in, and how it moves between them during a job lifecycle.\n\nstateDiagram-v2\ndirection LR\n[*] --> SUBMIT:::user\nSUBMIT --> Submitted\nSubmitted --> Running\nRunning --> FINISHED\nstate FINISHED {\n  direction LR\n  [*] --> Failed\n  [*] --> Stopped\n  [*] --> Completed\n}\nFINISHED:::user\n\nclassDef user fill:lightgray\n\nnote: Refreshing a Job object\nAn instance of a Job object reflects the state of the job when the job function was called. If you want to inspect the current state of a job, you must first \"refresh\" the job object, which can simply be done with the help of the job function.job = JuliaHub.job(job)","category":"section"},{"location":"reference/jobs/#jobs-apis-expose-ports","page":"Jobs","title":"Jobs with exposed ports","text":"Some JuliaHub jobs may expose ports and can be communicated with from the outside over the network (e.g. batch jobs that expose ports).\n\nIf the job exposes a port, it can be accessed at a dedicated hostname (see the .hostname property of the Job object). The server running on the job is always exposed on port 443 on the public hostname, and the communication is TLS-wrapped (i.e. you need to connect to it over the HTTPS protocol). In most cases, your requests to the job also need to be authenticated (see also the JuliaHub.request function).\n\nSee also: the guide on submitting batch jobs with open ports, expose argument for JuliaHub.submit_job, JuliaHub.request","category":"section"},{"location":"reference/jobs/#Reference","page":"Jobs","title":"Reference","text":"","category":"section"},{"location":"reference/jobs/#Index","page":"Jobs","title":"Index","text":"Pages = [\"jobs.md\"]\n\n","category":"section"},{"location":"reference/jobs/#JuliaHub.JobReference","page":"Jobs","title":"JuliaHub.JobReference","text":"const JobReference :: Type\n\nA type constraint on the arguments of many jobs-related functions that is used to specify the job. A job reference must be either a Job object, or an AbstractString containing the unique job ID.\n\n\n\n\n\n","category":"type"},{"location":"reference/jobs/#JuliaHub.jobs","page":"Jobs","title":"JuliaHub.jobs","text":"JuliaHub.jobs(; [limit::Integer], [auth::Authentication]) -> Vector{Job}\n\nRetrieve the list of jobs, latest first, visible to the currently authenticated user.\n\nBy default, JuliaHub only returns up to 20 jobs. However, this default limit can be overridden by passing the limit keyword (which must be a positive integer).\n\nwarning: Non-dynamic job objects\nJob objects represents the jobs when the objects were created (e.g. by a job function) and are not automatically kept up to date. To refresh the job information, you can pass the existing Job to JuliaHub.job before passing it to this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.job","page":"Jobs","title":"JuliaHub.job","text":"JuliaHub.job(job::JobReference; throw::Bool=true, [auth::Authentication]) -> Job\n\nFetch the details of a job based on the job reference ref. Will throw an InvalidRequestError if the job does not exist, or returns nothing if throw=false is passed.\n\nwarning: Non-dynamic job objects\nJob objects represents the jobs when the objects were created (e.g. by a job function) and are not automatically kept up to date. To refresh the job information, you can pass the existing Job to JuliaHub.job before passing it to this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.isdone","page":"Jobs","title":"JuliaHub.isdone","text":"JuliaHub.isdone(::Job)\n\nA helper function to check if a Job is \"done\", i.e. its status is one of Completed, Stopped, or Failed.\n\nwarning: Non-dynamic job objects\nJob objects represents the jobs when the objects were created (e.g. by a job function) and are not automatically kept up to date. As such, the result from this function may not represent the current live state of the job. To refresh the job information, you can pass the existing Job to JuliaHub.job before passing it to this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.wait_job","page":"Jobs","title":"JuliaHub.wait_job","text":"wait_job(\n    job::AbstractString;\n    interval::Integer = 30, [auth::Authentication]\n) -> Job\n\nBlocks until remote job referred to by the job reference job has completed, by polling it with every interval seconds. Returns an updated Job object.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.kill_job","page":"Jobs","title":"JuliaHub.kill_job","text":"JuliaHub.kill_job(job::JobRefererence; [auth::Authentication]) -> Job\n\nStop the job referred to by the job reference ref. Returns the updated Job object.\n\nSee also: Job.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.extend_job","page":"Jobs","title":"JuliaHub.extend_job","text":"JuliaHub.extend_job(job::JobReference, extension::Limit; [auth::Authentication]) -> Job\n\nExtends the time limit of the job referred to by the job reference ref by extension (Dates.Period, or Integer number of hours). Returns an updated Job object.\n\nSee Limit for more information on how the extension argument is interpreted. Note that Unlimited is not allowed as extension.\n\nSee also: Job.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.JobLogMessage","page":"Jobs","title":"JuliaHub.JobLogMessage","text":"struct JobLogMessage\n\nContains a single JuliaHub job log message, and has the following fields:\n\ntimestamp :: Union{ZonedDateTime, Nothing}: log message timestamp (in UTC)\nmessage :: Union{String, Nothing}: log message string. This generally corresponds to one line of printed output\n\nFields that can also be nothing may be missing for some log messages.\n\nSee also: job_logs, job_logs_buffered.\n\ncompat: No public constructors\nObjects of this type should not be constructed explicitly. The contructor methods are not considered to be part of the public API.\n\n\n\n\n\n","category":"type"},{"location":"reference/jobs/#JuliaHub.job_logs","page":"Jobs","title":"JuliaHub.job_logs","text":"JuliaHub.job_logs(job; offset::Integer = 0, [limit::Integer], [auth::Authentication]) -> Vector{JobLogMessage}\n\nFetches the log messages for the specified JuliaHub job. The job is specifed by passing the job name as a string, or by passing a Job object (i.e. job::Union{AbstractString,Job}). Returns the log messages as an array of JobLogMessage objects.\n\nOptionally, the function takes the following keyword arguments:\n\noffset::Integer: the offset of the first log message fetched (0 corresponds to the first message); for the first method, this defaults to 0; however, in the second (callback) case, if offset is not specified, any existing logs will be ignored.\nlimit::Integer: the maximum number of messages fetched (all by default)\n\nnote: No default limit\nThe limit keyword does not have a default limit, and so by default job_logs fetches all the log messages. This may take a while and require many requests to JuliaHub if the job has a huge number of log messages.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.job_logs_buffered","page":"Jobs","title":"JuliaHub.job_logs_buffered","text":"JuliaHub.job_logs_buffered(\n    [f::Base.Callable], job::Union{Job,AbstractString};\n    stream::Bool=true, [offset::Integer],\n    [auth::Authentication]\n) -> AbstractJobLogsBuffer\n\nA lower-level function to work with log streams, and is particularly useful when working with jobs that have not finished yet and are actively producing new log messages.\n\nThe function accepts the following arguments:\n\nf :: Base.Callable: an optional callback function that gets called every time the buffer is updated. The callback must take two arguments: f(::AbstractJobLogsBuffer, ::AbstractVector). The first argument is the buffer object itself, and the second argument will be passed a read-only view of all the logs that have been loaded into the buffer, including the new ones.\njob :: Union{Job,AbstractString}: either the job name or a Job object.\nstream :: Bool: if set to true, the buffer object will automatically pull new logs in a an asynchronous background task. The streaming can be stopped with interrupt!.\noffset :: Integer: optional non-negative value to specify the starting point of the buffer\n\nInterface of the returned object\n\nReturns an instance of the abstract AbstractJobLogsBuffer type. These objects contain log messages (of type JobLogMessage), but not all the log messages are immediately available. Instead, at any given time the buffer represents a continuous section of logs that can be extended in either direction.\n\nThe following functions can be used to interact with log buffers: job_logs_newer!, job_logs_older!, JuliaHub.hasfirst, JuliaHub.haslast. Additionally, the objects will have a .logs :: Vector{JobLogMessage} property that can be used to access the log messages that have been loaded into the buffer.\n\nSee also: job_logs, Job.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.job_logs_older!","page":"Jobs","title":"JuliaHub.job_logs_older!","text":"JuliaHub.job_logs_older!(\n    buffer::AbstractJobLogsBuffer; [count::Integer], [auth::Authentication]\n) -> AbstractJobLogsBuffer\n\nUpdates the AbstractJobLogsBuffer object by adding up to count log messages to the beginning of the buffer. If count is omitted, it will seek all the way to the beginning of the logs.\n\nIf all the logs have already been loaded into the buffer (i.e. JuliaHub.hasfirst(buffer) is true), the function is a no-op.\n\nSee also: job_logs_buffered, job_logs_newer!.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.job_logs_newer!","page":"Jobs","title":"JuliaHub.job_logs_newer!","text":"JuliaHub.job_logs_newer!(\n    buffer::AbstractJobLogsBuffer; [count::Integer], [auth::Authentication]\n) -> AbstractJobLogsBuffer\n\nUpdates the AbstractJobLogsBuffer object by adding up to count log messages to the end of the buffer. If count is omitted, it will seek all the way to the end of the current logs.\n\nFor a finished job, if all the logs have already been loaded into the buffer (i.e. JuliaHub.haslast(buffer) is true), the function is a no-op. If the buffer is actively streaming new logs for a running job,  then the function is also a no-op.\n\nSee also: job_logs_buffered, job_logs_older!.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.AbstractJobLogsBuffer","page":"Jobs","title":"JuliaHub.AbstractJobLogsBuffer","text":"abstract type AbstractJobLogsBuffer\n\nSupertype of possible objects returned by job_logs_buffered. See the job_logs_buffered function for a description of the interface.\n\n\n\n\n\n","category":"type"},{"location":"reference/jobs/#JuliaHub.hasfirst","page":"Jobs","title":"JuliaHub.hasfirst","text":"JuliaHub.hasfirst(::AbstractJobLogsBuffer) -> Bool\n\nDetermines whether the job log buffer has the first message of the job logs.\n\nSee also: haslast, job_logs_buffered.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.haslast","page":"Jobs","title":"JuliaHub.haslast","text":"JuliaHub.haslast(::AbstractJobLogsBuffer) -> Bool\n\nDetermines whether the job log buffer has the last message of the job logs. Note that if the job has not finished, this will always be false, since the job may produce additional logs.\n\nSee also: hasfirst, job_logs_buffered.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.interrupt!","page":"Jobs","title":"JuliaHub.interrupt!","text":"JuliaHub.interrupt!(::AbstractJobLogsBuffer; wait::Bool=true)\n\nCan be use to interrupt the asynchronous log streaming task. If the log buffer is not streaming, this function is a no-op.\n\nNote that the effect of JuliaHub.interrupt! may not be immediate and the function will block until the task has stopped. wait = false can be passed to make interrupt! return immediately, but in that case the buffer may stream for a little while longer.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.job_files","page":"Jobs","title":"JuliaHub.job_files","text":"JuliaHub.job_files(job::Job, [filetype::Symbol]) -> Vector{JobFile}\n\nReturn the list of inputs and/or output files associated job.\n\nThe optional filetype argument should be one of :input, :source, :result or :project, and can be used to filter the file list down to either just job input files (such as the appbundle or Julia environment files), or output files (such as the one uploaded via RESULTS_FILE).\n\nNote: job_file(job) is equivalent to job.files, and the latter is preferred. This function is primarily meant to be used when filtering by file type.\n\nSee also: Job.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.job_file","page":"Jobs","title":"JuliaHub.job_file","text":"JuliaHub.job_file(job::Job, type::Symbol, filename::AbstractString) -> JobFile | Nothing\n\nSearches for a job output file of a specified type and with the specific filename for job job, or nothing if the file was not found.\n\ntype should be one of the standard job file types. See JobFile and job_files for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.download_job_file","page":"Jobs","title":"JuliaHub.download_job_file","text":"JuliaHub.download_job_file(file::JobFile, path::AbstractString; [auth]) -> String\nJuliaHub.download_job_file(file::JobFile, io::IO; [auth])\n\nDownloads a JobFile to a local path. Alternative, writeable stream object can be passed as the second argument to write the contents directly into the stream.\n\nWhen a local path is passed, it returns the path (which can be useful when calling the function as e.g. JuliaHub.download_job_file(file, tempname()))). When an IO object is passed, it returns nothing.\n\nFor example, to download a file into a temporary file:\n\njulia> file = JuliaHub.job_file(JuliaHub.job(\"jr-eezd3arpcj\"), :result, \"outdir.tar.gz\")\nJuliaHub.JobFile outdir.tar.gz (jr-eezd3arpcj, :result, 632143 bytes)\nsha2_256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\nUploaded: 2023-03-15T07:59:29.473898+00:00\n\njulia> tmp = tempname()\n\"/tmp/jl_nE3uvkZwvC\"\n\njulia> JuliaHub.download_job_file(file, tmp)\n\"/tmp/jl_BmHgj8rQXe\"\n\njulia> bytes2hex(open(sha2_256, tmp))\n\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n\nAlternatively, you can also download the file into a writable IO stream, such as IOBuffer:\n\njulia> buffer = IOBuffer();\n\njulia> JuliaHub.download_job_file(file, buffer)\n\njulia> bytes2hex(sha2_256(take!(buffer)))\n\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n\nSee also: Job, JobFile.\n\n\n\n\n\n","category":"function"},{"location":"reference/jobs/#JuliaHub.Job","page":"Jobs","title":"JuliaHub.Job","text":"struct Job\n\nRepresents a single job submitted to JuliaHub. Objects have the following properties:\n\nid :: String: the unique, automatically generated ID of the job\nalias :: String: a non-unique, but descriptive alias for the job (often set by e.g. applications)\nstatus :: JobStatus: a string-like JobStatus object storing the state of the job\nenv :: Dict: a dictionary of environment variables that were set when the job was submitted\nresults :: String: the output value set via ENV[\"RESULTS\"] (an empty string if it was not explicitly set)\nfiles :: Vector{JobFiles}: a list of JobFile objects, representing the input and output files of the job (see: job_files, job_file, download_job_file).\nhostname :: Union{String, Nothing}: for jobs that expose a port over HTTP, this will be set to the hostname of the job (nothing otherwise; see: the relevant section in the manual)\n\nSee also: job, jobs.\n\nwarning: Non-dynamic job objects\nJob objects represents the jobs when the objects were created (e.g. by a job function) and are not automatically kept up to date. To refresh the job information, you can pass the existing Job to JuliaHub.job before passing it to this function.\n\ncompat: No public constructors\nObjects of this type should not be constructed explicitly. The contructor methods are not considered to be part of the public API.\n\n\n\n\n\n","category":"type"},{"location":"reference/jobs/#JuliaHub.JobStatus","page":"Jobs","title":"JuliaHub.JobStatus","text":"struct JobStatus\n\nType of the .status field of a Job object, representing the current state of the job. Should be one of: Submitted, Running, Failed, Stopped, Completed.\n\nIn practice, the .status field should be treated as string and only used in string comparisons.\n\nSee also: isdone.\n\njulia> job = JuliaHub.job(\"jr-novcmdtiz6\")\nJuliaHub.Job: jr-novcmdtiz6 (Completed)\n submitted: 2023-03-15T07:56:50.974+00:00\n started:   2023-03-15T07:56:51.251+00:00\n finished:  2023-03-15T07:56:59.000+00:00\n files:\n  - code.jl (input; 3 bytes)\n  - code.jl (source; 3 bytes)\n  - Project.toml (project; 244 bytes)\n  - Manifest.toml (project; 9056 bytes)\n outputs: \"{}\"\n\njulia> job.status == \"Submitted\"\nfalse\n\njulia> job.status == \"Completed\"\ntrue\n\ncompat: No public constructors\nObjects of this type should not be constructed explicitly. The contructor methods are not considered to be part of the public API.\n\n\n\n\n\n","category":"type"},{"location":"reference/jobs/#JuliaHub.JobFile","page":"Jobs","title":"JuliaHub.JobFile","text":"struct JobFile\n\nA reference to a job input or output file, with the following properties:\n\n.name :: String: the name of the Job this file is attached to\n.type :: Symbol: indicated the file type (see below)\n.filename :: String: file name\n.size :: Int: size of the file in bytes (reported to be zero in cases where the file contents is missing)\n.hash :: Union{FileHash, Nothing}: a FileHash object containing the file hash, but may also be missing (nothing) in some cases, like when the file upload has not completed yet.\n\nThe file is uniquely identified by the (job, type, filename) triplet.\n\nThe type of the file should be one of:\n\n:input: various job input files, which includes code, environment, and appbundle files.\n:source: source\n:project: Julia project environment files (e.g. Project.toml, Manifest.toml, Artifacts.toml)\n:result: output results file, defined via the RESULTS_FILE environment variable in the job\n\nNote that some files are duplicated under multiple categories.\n\nSee also: Job, job_files, job_file.\n\ncompat: No public constructors\nObjects of this type should not be constructed explicitly. The contructor methods are not considered to be part of the public API.\n\n\n\n\n\n","category":"type"},{"location":"reference/jobs/#JuliaHub.FileHash","page":"Jobs","title":"JuliaHub.FileHash","text":"struct FileHash\n\nStores a hash and the algorithm used to calcute it. The object has the following properties:\n\n.algorithm :: Symbol: hash algorithm\n.hash :: Vector{UInt8}: the hash as a sequence of bytes\n\ncompat: No public constructors\nObjects of this type should not be constructed explicitly. The contructor methods are not considered to be part of the public API.\n\n\n\n\n\n","category":"type"},{"location":"reference/jobs/#JuliaHub.request","page":"Jobs","title":"JuliaHub.request","text":"function request(\n    job::Job,\n    method::AbstractString,\n    uripath::AbstractString,\n    [body];\n    [auth::Authentication],\n    [extra_headers],\n    kwargs...\n) -> HTTP.Response\n\nPerforms an authenticated HTTP request against the HTTP server exposed by the job (with the authentication token of the currently authenticated user). The function is a thin wrapper around the HTTP.request function, constructing the correct URL and setting the authentication headers.\n\nArguments:\n\njob::Job: JuliaHub job (from JuliaHub.job)\nmethod::AbstractString: HTTP method (gets directly passed to HTTP.jl)\nuripath::AbstractString: the path and query portion of the URL, which gets appended to the scheme and hostname port of the URL. Must start with a /.\nbody: gets passed as the body argument to HTTP.jl\n\nKeyword arguments:\n\nauth :: Authentication: optional authentication object (see the authentication section for more information)\n\nextra_headers: an iterable of extra HTTP headers, that gets concatenated with the list of necessary authentication headers and passed on to HTTP.request.\nAdditional keyword arguments must be valid HTTP.jl keyword arguments and will get directly passed to the HTTP.request function.\n\nnote: Note\nSee the manual section on jobs with exposed ports and the expose argument to submit_job.\n\n\n\n\n\n","category":"function"},{"location":"reference/job-submission/#job-submission","page":"Job submission","title":"Job submission","text":"On JuliaHub you can submit jobs, which are user-defined workloads that get allocated a dedicated compute capacity. For example, this includes running scripts in batch computations, cloud IDEs, interactive notebooks and so on. The functions and types here deal with starting up such jobs and apps. The functions to inspect running or finished jobs are documented separately.\n\nPages=[\"job-submission.md\"]\nDepth=2:3\n\nA complete JuliaHub job workload is defined by the following configuration pieces:\n\nJob configuration. This specifies the computation that gets run, and includes information such as the type of computation (batch script vs starting a GUI application), any arguments or Julia code that gets passed to the job etc.\nAs of now, there are three general types of jobs that can be run on JuliaHub:\nBatch jobs: non-interactive Julia scripts\nDefault Applications: special, built-in, interactive applications (such as IDEs or product-specific dashboards)\nExternal package applications: Julia packages that can be run as either interactive or non-interactive jobs\nEach of these categories are configured slightly differently, and are described in more detail below.\nCompute configuration. This specifies the hardware and cluster topology that will be used to execute the job (such as the number of CPUs per node, whether there is a GPU present, the number of nodes), how the Julia processes are configured (e.g. single process per node vs process per cpu), and other low-level technical configuration.\nRuntime parameters. These are various additional parameters that control how a job behaves. Currently, this is limited to passing environment variables to the jobs, overriding the job's name in the UI, and to various configuration options related to running interactive jobs.\n\nIn the JuliaHub.jl code, the first two categories are encapsulated by the AbstractJobConfig and ComputeConfig types. These two, together with the additional runtime parameters, make up a WorkloadConfig object that can be submitted to JuliaHub for executing with the submit_job function.\n\nThe following sections on this page explain the different aspects of job submission in more detail. See the guide on submitting batch jobs to see more practical examples of how to submit jobs.","category":"section"},{"location":"reference/job-submission/#Compute-configuration","page":"Job submission","title":"Compute configuration","text":"JuliaHub supports a predefined set of node configurations, each of which have a specific number of CPUs, memory, GPUs etc. A JuliaHub job must pick one of these node types to run on, although a distributed job can run across multiple instances of the same node type. A list of these node specifications can be obtained with the nodespecs function (returning a list of NodeSpec objects).\n\njulia> JuliaHub.nodespecs()\n9-element Vector{JuliaHub.NodeSpec}:\n JuliaHub.nodespec(#= m6: 3.5 GHz Intel Xeon Platinum 8375C, 0.17/hr =#; ncpu=2, memory=8, ngpu=false, exactmatch=true)\n JuliaHub.nodespec(#= r6: 3.5 GHz Intel Xeon Platinum 8375C, 0.22/hr =#; ncpu=2, memory=16, ngpu=false, exactmatch=true)\n JuliaHub.nodespec(#= m6: 3.5 GHz Intel Xeon Platinum 8375C, 0.33/hr =#; ncpu=4, memory=16, ngpu=false, exactmatch=true)\n JuliaHub.nodespec(#= r6: 3.5 GHz Intel Xeon Platinum 8375C, 0.42/hr =#; ncpu=4, memory=32, ngpu=false, exactmatch=true)\n JuliaHub.nodespec(#= m6: 3.5 GHz Intel Xeon Platinum 8375C, 0.65/hr =#; ncpu=8, memory=32, ngpu=false, exactmatch=true)\n JuliaHub.nodespec(#= r6: 3.5 GHz Intel Xeon Platinum 8375C, 1.3/hr =#; ncpu=8, memory=64, ngpu=false, exactmatch=true)\n JuliaHub.nodespec(#= m6: 3.5 GHz Intel Xeon Platinum 8375C, 2.4/hr =#; ncpu=32, memory=128, ngpu=false, exactmatch=true)\n JuliaHub.nodespec(#= p2: Intel Xeon E5-2686 v4 (Broadwell), 1.4/hr =#; ncpu=4, memory=61, ngpu=true, exactmatch=true)\n JuliaHub.nodespec(#= p3: Intel Xeon E5-2686 v4 (Broadwell), 4.5/hr =#; ncpu=8, memory=61, ngpu=true, exactmatch=true)\n\nWhile you can manually index into the list returned by nodespecs, that is generally inconvenient. Instead, the nodespec function should be used to find a suitable node for a particular job.\n\njulia> JuliaHub.nodespec(ncpu=2, memory=8)\nNode: 3.5 GHz Intel Xeon Platinum 8375C\n - GPU: no\n - vCores: 2\n - Memory: 8 Gb\n - Price: 0.17 $/hr\n\nBy default, nodespec finds the smallest node that satisfies the specified requirements. However, it also supports the exactmatch argument, which can be use to find the exactly matching node configuration.\n\njulia> JuliaHub.nodespec(ncpu=3, memory=5; exactmatch=true)\nERROR: InvalidRequestError: Unable to find a nodespec: ncpu=3 memory=5 gpu=false\nStacktrace:\n ...\n\njulia> JuliaHub.nodespec(ncpu=3, memory=5)\nNode: 3.5 GHz Intel Xeon Platinum 8375C\n - GPU: no\n - vCores: 4\n - Memory: 16 Gb\n - Price: 0.33 $/hr\n\nBy default, JuliaHub jobs run on a single node. However, for a distributed job, additional nodes can be allocated to a job by specifying the nnodes parameter. In that case, a Julia process is started on each node, and the additional nodes are linked to the main process via the Distributed module.\n\nWhile by default only a single Julia process is started on each node, by setting the process_per_cpu parameter, multiple Julia processes are started on the same node. The processes are isolated from each other by running in separate containers, but they share the CPUs, GPUs, and most crucially, the memory.\n\nSee ComputeConfig and submit_job for more details on how exactly to set up this configuration.","category":"section"},{"location":"reference/job-submission/#jobs-runtime-config","page":"Job submission","title":"Runtime configuration","text":"The submit_job function accepts various additional parameters that control aspects of the job. See the function's docstring for more details.\n\nParameter Description\nname can be used to override the name of the job shown in the UI\nproject specifies the JuliaHub project UUID that the job is associate with\ntimelimit sets the time limit after which the job gets killed\nenv environment variables set at runtime\n\nAs an example, to have an environment variable set while the job is running, you could call submit_job as follows:\n\nimport JuliaHub # hide\nJuliaHub.submit_job(\n    JuliaHub.script\"\"\"\n    @info \"Extracting 'MY_PARAMETER'\" get(ENV, \"MY_PARAMETER\", nothing)\n    \"\"\",\n    env = Dict(\"MY_PARAMETER\" => \"example value\"),\n    dryrun = true\n)","category":"section"},{"location":"reference/job-submission/#jobs-batch","page":"Job submission","title":"Batch jobs","text":"Batch jobs are Julia scripts with (optional) associated Julia package environments (Project.toml, Manifest.toml and/or Artifacts.toml) that run on the cluster non-interactively.\n\nSee also: @script_str, script, appbundle for more details, and the guide on submitting batch jobs for a tutorial.","category":"section"},{"location":"reference/job-submission/#jobs-batch-juliabundleignore","page":"Job submission","title":".juliabundleignore file","text":"A .juliabundleignore file can be use to exclude certain files from the appbundle that gets submitted to JuliaHub. This is useful if you have some temporary development or data files in your project directory, in particular if they are large.\n\nGenerally, the file is similar to a .gitignore file (though not as feature rich), containing a list of glob patterns. More precisely, it uses Glob.jl to match the patterns in the file against file system paths.\n\nFor example, a valid .juliabundleignore might contain the following entries to exclude a particular directory and all CSV files:\n\noutput.log\n*.csv\noutput-data/\n\nThis .juliabundleignore will ignore:\n\nThe output.log file next to the .juliabundleignore.\nAll .csv files next to the .juliabundleignore and in subdirectories.\nAll the contents of the output-data/ directory next to the .juliabundleignore.\n\nYou can also have additional .juliabundleignore files in subdirectories and they will only apply to those directories and their subdirectories.","category":"section"},{"location":"reference/job-submission/#Specifying-the-job-image","page":"Job submission","title":"Specifying the job image","text":"JuliaHub batch jobs can run in various container images. Different JuliaHub products often have their own image tailored for the application (e.g. that come with custom sysimages to reduce load times).\n\nThe list of all images available to the user can be obtained with batchimages, and a specific one can be picked out with batchimage. The latter function is particularly useful when submitting jobs.\n\nJuliaHub.submit_job(\n    JuliaHub.BatchJob(\n        JuliaHub.script\"\"\"\n        using SpecialProductModule\n        SpecialProductModule.run()\n        \"\"\",\n        image = JuliaHub.batchimage(\"specialproduct\"),\n    )\n)","category":"section"},{"location":"reference/job-submission/#jobs-default-apps","page":"Job submission","title":"Default Applications","text":"compat: Experimental feature\nStarting application jobs with JuliaHub.jl is considered to be experimental. The APIs are likely to change in future JuliaHub.jl version.\n\nDefault applications are the JuliaHub-built in applications (such as dashboards and IDEs), generally associated with specific JuliaHub products. Specific examples of default applications available to everyone include the Pluto notebooks and the Julia IDE.\n\nThe list of available applications can be accessed via the applications function, and specific applications can be picked out with application.\n\njulia> apps = JuliaHub.applications()\n7-element Vector{JuliaHub.AbstractJuliaHubApp}:\n JuliaHub.application(:default, \"Linux Desktop\")\n JuliaHub.application(:default, \"Julia IDE\")\n JuliaHub.application(:default, \"Pluto\")\n JuliaHub.application(:default, \"Windows Workstation\")\n JuliaHub.application(:package, \"RegisteredPackageApp\")\n JuliaHub.application(:package, \"CustomDashboardApp\")\n JuliaHub.application(:user, \"ExampleApp.jl\")\n\njulia> JuliaHub.application(:default, \"Pluto\")\nDefaultApp\n name: Pluto\n key: pluto\n\nA JuliaHub job that launches an application can be started by passing the object returned by the application function to submit_job.\n\nimport JuliaHub # hide\nJuliaHub.submit_job(\n    JuliaHub.application(:default, \"Pluto\"),\n    ncpu = 8, memory = 16,\n)","category":"section"},{"location":"reference/job-submission/#jobs-packages","page":"Job submission","title":"External package applications","text":"compat: Experimental feature\nStarting package application jobs with JuliaHub.jl is considered to be experimental. The APIs are likely to change in future JuliaHub.jl version.\n\nSpecially crafted Julia packages can also be launched as JuliaHub jobs. They are either automatically picked up from the packages registries served by the JuliaHub instance (PackageApp), or added by users themselves (UserApp) via a Git URL.\n\nA package application must have a top-level package environment (i.e. it has a Project.toml the declares a name and a UUID), and it must have a entry script at bin/main.jl. When a package job starts, the package is added to an environment and bin/main.jl is called. Note that the bin/main.jl script does not have any access to any of the package dependencies.\n\nThe applications function can list all available packages (with filtering for user or registered). JuliaHub.application can be used to pick a package by name. It works for both registered packages\n\nJuliaHub.submit_job(\n    JuliaHub.application(:package, \"RegisteredPackageApp\"),\n    ncpu = 4,\n)\n\nand for private, user applications\n\nJuliaHub.submit_job(\n    JuliaHub.application(:user, \"ExampleApp.jl\"),\n    ncpu = 4,\n    env = Dict(\"example_parameter\" => \"2\")\n)\n\ntip: Environment variables\nEnvironment variables (i.e. env) are a common way to communicate options and settings to package applications.","category":"section"},{"location":"reference/job-submission/#Reference","page":"Job submission","title":"Reference","text":"","category":"section"},{"location":"reference/job-submission/#Experimental-APIs","page":"Job submission","title":"Experimental APIs","text":"compat: Experimental features\nStarting application jobs with JuliaHub.jl is considered to be experimental. The APIs are likely to change in future JuliaHub.jl version.","category":"section"},{"location":"reference/job-submission/#Index","page":"Job submission","title":"Index","text":"Pages = [\"job-submission.md\"]\n\n","category":"section"},{"location":"reference/job-submission/#JuliaHub.NodeSpec","page":"Job submission","title":"JuliaHub.NodeSpec","text":"struct NodeSpec\n\nStores information about a compute node that can be allocated for JuliaHub jobs. The list of all available node specifications can be accessed with nodespecs, or specific ones searched with nodespec.\n\njulia> JuliaHub.nodespec()\nNode: 3.5 GHz Intel Xeon Platinum 8375C\n - GPU: no\n - vCores: 2\n - Memory: 8 Gb\n - Price: 0.17 $/hr\n\nThey can be used to contruct explicit compute configuration objects when submitting JuliaHub jobs.\n\nSee also: submit_job, ComputeConfig.\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.nodespecs","page":"Job submission","title":"JuliaHub.nodespecs","text":"JuliaHub.nodespecs(; auth::Authentication) -> Vector{NodeSpec}\n\nQuery node specifications available on the current server, returning a list of NodeSpec objects.\n\n\n\n\n\n","category":"function"},{"location":"reference/job-submission/#JuliaHub.nodespec","page":"Job submission","title":"JuliaHub.nodespec","text":"JuliaHub.nodespec(\n    [nodes::Vector{NodeSpec}];\n    ncpu::Integer=1, ngpu::Integer=false, memory::Integer=1,\n    exactmatch::Bool=false, throw::Bool=true,\n    [auth::Authentication]\n) -> Union{NodeSpec, Nothing}\n\nFinds the node matching the specified node parameters. Throws an InvalidRequestError if it is unable to find a node with the specific parameters. However, if throw is set to false, it will return nothing instead in that situation.\n\nBy default, it searches for the smallest node that has the at least the specified parameters (prioritizing GPU count, CPU count, and memory in this order when deciding). If exactmatch is set to true, it only returns a node specification if it can find one that matches the parameters exactly.\n\nA list of nodes (e.g. from nodespecs) can also be passed, so that the function does not have to query the server for the list. When this method is used, it is not necessary to pass auth.\n\n\n\n\n\n","category":"function"},{"location":"reference/job-submission/#JuliaHub.BatchImage","page":"Job submission","title":"JuliaHub.BatchImage","text":"struct BatchImage\n\nRepresents an available JuliaHub batch job image. These can be passed to BatchJob to specify which underlying job image will be used for the job.\n\nA list of available batch images can be accessed with batchimages and specific images can be constructed with batchimage.\n\ncompat: No public constructors\nObjects of this type should not be constructed explicitly. The contructor methods are not considered to be part of the public API.\n\nSee also: batchimages, batchimage, BatchJob, script, appbundle.\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.batchimages","page":"Job submission","title":"JuliaHub.batchimages","text":"JuliaHub.batchimages([product::AbstractString]; [auth::Authentication]) -> Vector{BatchImage}\n\nReturn the list of all batch job images available to the currently authenticated user, as a list of BatchImage objects. These can be passed to BatchJob.\n\nOptionally, by passing a product identifier, the list can be narrowed down to images available for that specific product.\n\nnote: Batch images on older instances\nWhen using the package with an older JuliaHub instance (<= 6.1), the non-default batch images show up with @legacy as the product name. This indicates that the package is using an older API, and not that the images themselves are outdated.\n\nSee also: BatchImage, batchimage, BatchJob, script, appbundle.\n\n\n\n\n\n","category":"function"},{"location":"reference/job-submission/#JuliaHub.batchimage","page":"Job submission","title":"JuliaHub.batchimage","text":"JuliaHub.batchimage(\n    [product::AbstractString, [image::AbstractString]];\n    throw::Bool=true, [auth::Authentication]\n) -> BatchImage\n\nPick a product job batch image from the list of all batch image, returning a BatchImage object. If image is omitted, it will return the default image corresponding to product. If product is omitted as well, it will return the default image of the instance (generally the standard Julia batch image).\n\nWill throw an InvalidRequestError if the specified image can not be found. If throw=false, it will return nothing instead in this situation.\n\nnote: Batch images on older instances\nWhen using the package with an older JuliaHub instance (<= 6.1), the non-default batch images show up with @legacy as the product name. This indicates that the package is using an older API, and not that the images themselves are outdated.\n\nSee also: BatchImage, batchimages, BatchJob, script, appbundle.\n\n\n\n\n\n","category":"function"},{"location":"reference/job-submission/#JuliaHub.AbstractJobConfig","page":"Job submission","title":"JuliaHub.AbstractJobConfig","text":"abstract type AbstractJobConfig\n\nAbstract supertype of all application configuration types that can be passed to submit_job for submission as a JuliaHub job. The package has built-in support for the following application configurations:\n\nJuliaHub.BatchJob\nJuliaHub.ApplicationJob\nJuliaHub.PackageApp\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.BatchJob","page":"Job submission","title":"JuliaHub.BatchJob","text":"struct BatchJob <: AbstractJobConfig\n\nRepresents the application configuration of a JuliaHub batch job. A batch job is defined by the following information:\n\nThe Julia code that is to be executed in the job.\nJulia package environment (i.e. Project.toml, Manifest.toml) and other files, such as the appbundle.\nThe underlying batch job container image (see also batchimages), which defaults to the standard Julia image by default.\n\nInstances of this types should normally not be constructed directly, and the following functions should be used instead:\n\nscript or @script_str: for submitting simple Julia scripts or code snippets\nappbundle: for submitting more complex \"appbundles\" that include additional file, private or modified package dependencies etc.\n\nOptional arguments\n\nimage  :: Union{BatchImage, Nothing}: can be used to specify which product's batch job image will be used when running the job, by passing the appropriate BatchImage object (see also: batchimage and batchimages). If set to nothing (the default), the job runs with the default Julia image.\nsysimage :: Bool: if set to true, requests that a system image is built from the job's Manifest.toml file before starting the job. Defaults to false.\n\ncompat: JuliaHub compatibility\nThe sysimage = true option requires JuliaHub 6.3 to have an effect. When running against older JuliaHub versions, it does not have an effect.\n\nConstructors\n\nBatchJob(::BatchJob; [image::BatchImage], [sysimage::Bool]) -> BatchJob\n\nConstruct a BatchJob, but override some of the optional arguments documented above. When the argument is omitted, the value from the underlying BatchJob object is used. This is the only constructor that is part of the public API.\n\nThis method is particularly useful when used in in combination with the @script_str string macro, to be able to specify the job image or trigger a sysimage build. For example, the following snippet will set a different batch image for the script-type job:\n\nJuliaHub.BatchJob(\n    JuliaHub.script\"\"\"\n    @info \"Hello World\"\n    \"\"\",\n    image = JuliaHub.batchimage(\"...\")\n)\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.script","page":"Job submission","title":"JuliaHub.script","text":"JuliaHub.script(...) -> BatchJob\n\nConstructs the configuration for a script-type batch job, returning the respective BatchJob object that can then be passed to submit_job. A script-type batch job is defined by the following:\n\nA user-provided Julia script that gets executed on the server. Note that no validation of the input code is done.\nAn optional Julia package environment (e.g. Project.toml, Manifest.toml and Artifacts.toml). If any of the TOML files are provided, they must parse as valid TOML files, but no further validation is done client-side.\nIf the manifest is not provided, the project environment must be instantiated from scratch, generally pulling in the latest versions of all the dependencies (although [compat] sections are honored).\nIt is also fine to omit the project file, and just provide the manifest, and the environment defined by the manifest still gets instantiated. If both are omitted, the job runs in an empty environment.\nA JuliaHub job image, which determines the container environment that will be used to execute the code in (see batchimage, batchimages, BatchImage). If omitted, the default Julia image is used.\n\nSee also the @script_str string macro to more easily submit simple scripts that are defined in code.\n\nMethods\n\nscript(\n    scriptfile::AbstractString;\n    [project_directory::AbstractString], [image::BatchImage], [sysimage::Bool]\n) -> BatchJob\n\nConstructs a script-type batch job configuration the will execute the code in scriptfile. Optionally, a path to a project environment directory can be passed via project_directory, which will be searched for the environment TOML files, and a job image can be specified via image.\n\nscript(;\n    code::AbstractString,\n    [project::AbstractString], [manifest::AbstractString], [artifacts::AbstractString],\n    [image::BatchImage], [sysimage::Bool]\n) -> BatchJob\n\nA lower-level method that can be used to construct the script-type BatchJob configuration directly in memory (i.e. without having to write out intermediate files).\n\nThe code keyword argument is mandatory and will specify contents of the Julia script that gets executed on the server. The Julia project environment can be specified by passing the contents of the TOML files via the corresponding arguments (project, manifest, artifacts). The job image can be specified via image.\n\nnote: Optional arguments\nSee BatchJob for a more thorough description of the optional arguments.\n\n\n\n\n\n","category":"function"},{"location":"reference/job-submission/#JuliaHub.@script_str","page":"Job submission","title":"JuliaHub.@script_str","text":"JuliaHub.@script_str -> JuliaHub.BatchJob\n\nA string macro to conveniently construct a script-type batch job configuration (BatchJob) that can be submitted as a JuliaHub job.\n\nscript = JuliaHub.script\"\"\"\n@info \"Hello World!\"\n\"\"\"\n\nThis allows for an easy submission of simple single-script jobs to JuliaHub:\n\nJuliaHub.submit_job(\n    JuliaHub.script\"\"\"\n    @info \"Hello World!\"\n    \"\"\"\n)\n\nBy default, the macro picks up the currently active Julia project environment (via Base.active_project()), and attaches the environment .toml files to the script. To disable this, you can call the macro with the noenv suffix, e.g.\n\nscript = JuliaHub.script\"\"\"\n@info \"Hello World!\"\n\"\"\"noenv\n\nHowever, if your local environment has development dependencies, you likely need to use an appbundle instead (see appbundle).\n\nnote: Using a different job image\nThere is no way to specify the job image with the string macro, and it will use the default Julia image. To use a different job image, you should either use the script function, either by fully constructing the batch job configuration with the keyword arguments, or by using the BatchJob(::BatchJob; image=...) method.JuliaHub.submit_job(\n    JuliaHub.BatchJob(\n        JuliaHub.script\"\"\"\n        @info \"Hello World!\"\n        \"\"\",\n        image = JuliaHub.batchimage(...)\n    )\n)You can also use this pattern to set the sysimage option.\n\n\n\n\n\n","category":"macro"},{"location":"reference/job-submission/#JuliaHub.appbundle","page":"Job submission","title":"JuliaHub.appbundle","text":"JuliaHub.appbundle(\n    directory::AbstractString, codefile::AbstractString;\n    [image::BatchImage], [sysimage::Bool]\n) -> BatchJob\nJuliaHub.appbundle(\n    directory::AbstractString;\n    code::AbstractString, [image::BatchImage], [sysimage::Bool]\n) -> BatchJob\n\nConstruct an appbundle-type JuliaHub batch job configuration. An appbundle is a directory containing a Julia environment that is bundled up, uploaded to JuliaHub, and then unpacked and instantiated as the job starts.\n\nThe primary, two-argument method will submit a job that runs a file from within the appbundle (specified by codefile, which must be a path relative to the root of the appbundle). The code that gets executed is read from codefile, which should be a path to Julia source file relative to directory.\n\nJuliaHub.appbundle(@__DIR__, \"my-script.jl\")\n\nAlternatively, if codefile is omitted, the code must be provided as a string via the code keyword argument.\n\nJuliaHub.appbundle(\n    @__DIR__,\n    code = \"\"\"\n    @show ENV\n    \"\"\"\n)\n\nSee BatchJob for a description of the optional arguments.\n\nExtended help\n\nThe following should be kept in mind about how appbundles are handled:\n\nThe bundler looks for a Julia environment (i.e. Project.toml and/or Manifest.toml files) at the root of the directory. If the environment does not exist (i.e. the files are missing), the missing files are created. If the manifest is missing, then the environment is re-instantiated from scratch based on the contents of Project.toml. The generated files will also be left in the user-provided directory directory.\nDevelopment dependencies of the environment (i.e. packages added with pkg> develop or Pkg.develop()) are also bundled up into the archive that gets submitted to JuliaHub (including any current, uncommitted changes). Registered packages are installed via the package manager via the standard environment instantiation, and their source code is not included in the bundle directly.\nYou can use .juliabundleignore files to omit some files from the appbundle (secrets, large data files etc). See the relevant section in the reference manual for more details.\nWhen the JuliaHub job starts, the bundle is unpacked and the job's starting working directory is set to the root of the unpacked appbundle directory, and you can e.g. load the data from those files with just read(\"my-data.txt\", String).\ncompat: JuliaHub 6.2 and older\nOn some JuliaHub versions (6.2 and older), the working directory was set to the parent directory of unpacked appbundle (with the appbundle directory called appbundle), and so it was necessary to do joinpath(\"appbundle\", \"mydata.dat\") to load files.\nWhen submitting appbundles with the two-argument codefile method, you can expect @__DIR__ and include to work as expected.\nHowever, when submitting the Julia code as a string (via the code keyword argument), the behavior of @__DIR__ and include should be considered undefined and subject to change in the future.\nThe one-argument + code keyword argument method is a lower-level method, that more closely mirrors the underlying platform API. The custom code that is passed via code is sometimes referred to as the \"driver script\", and the two-argument method is implemented by submitting an automatically constructed driver script that actually loads the specified file.\n\ncompat: Deprecation: v0.1.10\nAs of JuliaHub.jl v0.1.10, the ability to launch appbundles using the two-argument method where the codefile parameter point to a file outside of the appbundle itself, is deprecated. You can still submit the contents of the script as the driver script via the code keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"reference/job-submission/#JuliaHub.ComputeConfig","page":"Job submission","title":"JuliaHub.ComputeConfig","text":"struct ComputeConfig\n\nThis type encapsulates the configuration of a jobs's compute cluster, including the hardware configuration and the cluster topology.\n\nSee also: submit_job.\n\nConstructors\n\nJuliaHub.ComputeConfig(\n    node::NodeSpec;\n    nnodes::Integer = 1,\n    process_per_node::Bool = true,\n    elastic::Bool = false,\n)\n\nnode: a NodeSpec object that specifies the hardware of a single node.\nnnodes::Union{Integer, Tuple{Integer, Integer}} = 1: specifies the number of nodes of type node that will be allocated. Alternatively, a two-integer tuple can also be passed, where the first value specifies the minimum number of nodes required to start a job. By default, a single-node job is started.\nprocess_per_node::Bool = true: if true, there will only be a single Julia process per node, and the total number of Julia processes will be nnodes. If set to false, however, each core on each node will be allocated a separate Julia process (running in an isolated container on the same node), and so the total number of Julia processes will be nnodes Ã— ncpu, and it will essentially always be a multi-process job.\nelastic::Bool = false: if set, the job will be started in an elastic cluster mode. In this case, a minimum number of nnodes must not be passed.\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.submit_job","page":"Job submission","title":"JuliaHub.submit_job","text":"JuliaHub.submit_job(\n    app::Union{AbstractJuliaHubApp, AbstractJobConfig},\n    [compute::ComputeConfig];\n    # Compute keyword arguments\n    ncpu::Integer = 1, ngpu::Integer = 0, memory::Integer = 1,\n    nnodes::Integer = 1, minimum_nnodes::Union{Integer,Nothing} = nothing,\n    elastic::Bool = false,\n    process_per_node::Bool = true,\n    # Runtime configuration keyword arguments\n    [alias::AbstractString], [env], [expose::Integer],\n    [project::Union{UUID, AbstractString}], timelimit::Limit = Hour(1),\n    # General keyword arguments\n    dryrun::Bool = false,\n    [auth :: Authentication]\n) -> Job\n\nSubmits the specified application config app as a job to JuliaHub. Returns a Job object corresponding to the submitted job.\n\nCompute arguments. If compute is passed, the compute keyword arguments can not be passed. If compute is not passed, the following arguments can be used to specify the compute configration via keyword arguments:\n\nncpu, ngpu and memory are used to pick a node type that will be used to run the job. The node type will be a minimum one that satisfies the constraints, but may have more compute resources than specified by the arguments (it corresponds to the exactmatch = false case of nodespec).\nnnodes, minimum_nnodes, process_per_node, and elastic specify the corresponding arguments in ComputeConfig.\n\nRuntime configuration. These are used to set the Runtime configuration of the job.\n\nalias :: Union{AbstractString, Nothing}: can be used to override the name of the job that gets displayed in the UI. Passing nothing is equivalent to omitting the argument.\ntimelimit :: Limit: sets the job's time limit (see Limit for valid values)\nenv: an iterable of key-value pairs that can be used to set environment variable that get set before, the job code gets executed.\nproject :: Union{UUID, AbstractString, Nothing}: the UUID of the project that the job will be associated with. If a string is passed, it must parse as a valid UUID. Passing nothing is equivalent to omitting the argument.\nexpose :: Union{Integer, Nothing}: if set to an integer in the valid port ranges, that port will be exposed over HTTPS, allowing for (authenticated) HTTP request to be performed against the job, as long as the job binds an HTTP server to that port. The allowed port ranges are 1025-9008,9010-23399,23500-32767(in other words,<= 1024,9009,23400-23499, and>= 32768` can not be used). See the relevant manual section for more information.\n\nGeneral arguments.\n\nauth :: Authentication: optional authentication object (see the authentication section for more information)\n\ndryrun :: Bool: if set to true, submit_job does not actually submit the job, but instead returns a WorkloadConfig object, which can be used to inspect the configuration that would be submitted.\nThe WorkloadConfig object can then be submitted to JuliaHub with the additional submit_job method:\nJuliaHub.submit_job(::WorkloadConfig; [auth::Authentication])\n\ncompat: JuliaHub compatibility\nThe timelimit = JuliaHub.Unlimited() argument requires JuliaHub 6.3+.\n\n\n\n\n\n","category":"function"},{"location":"reference/job-submission/#JuliaHub.Limit","page":"Job submission","title":"JuliaHub.Limit","text":"JuliaHub.Limit\n\nType-constraint on JuliaHub job timelimit arguments in submit_job.\n\nThe job time limit can either be a time period (an instance of Dates.Period), an Integer, (interpreted as the number of hours), or JuliaHub.Unlimited().\n\nOnly an integer number of hours are accepted by JuliaHub, and fractional hours from get rounded up to the next full integer number of hours (e.g. Dates.Minute(90) will be interpreted as 2 hours).\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.Unlimited","page":"Job submission","title":"JuliaHub.Unlimited","text":"struct Unlimited\n\nAn instance of this type can be passed as the [timelimit] option to submit_job to start jobs that run indefinitely, until killed manually.\n\nJuliaHub.submit_job(..., timelimit = JuliaHub.Unlimited())\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.WorkloadConfig","page":"Job submission","title":"JuliaHub.WorkloadConfig","text":"struct WorkloadConfig\n\nRepresents a full job configuration, including the application, compute and runtime configuration.\n\nInstances of this type can be constructed by passing dryrun = true to submit_job, and can also be directly submitted to JuliaHub with the same function.\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.AbstractJuliaHubApp","page":"Job submission","title":"JuliaHub.AbstractJuliaHubApp","text":"abstract type AbstractJuliaHubApp\n\nAbstract supertype for JuliaHub applications object types.\n\ncompat: Experimental API\nApplications-related APIs are experimental, and may be changed or removed without notice.\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.applications","page":"Job submission","title":"JuliaHub.applications","text":"JuliaHub.applications([category::Symbol]; [auth::Authentication]) -> Vector{AbstractJuliaHubApp}\n\nReturns the list of applications enabled for the authenticated user, optionally in the specified category only. Returns a vector of AbstractJuliaHubApp instances.\n\njulia> JuliaHub.applications()\n7-element Vector{JuliaHub.AbstractJuliaHubApp}:\n JuliaHub.application(:default, \"Linux Desktop\")\n JuliaHub.application(:default, \"Julia IDE\")\n JuliaHub.application(:default, \"Pluto\")\n JuliaHub.application(:default, \"Windows Workstation\")\n JuliaHub.application(:package, \"RegisteredPackageApp\")\n JuliaHub.application(:package, \"CustomDashboardApp\")\n JuliaHub.application(:user, \"ExampleApp.jl\")\n\njulia> JuliaHub.applications(:default)\n4-element Vector{JuliaHub.DefaultApp}:\n JuliaHub.application(:default, \"Linux Desktop\")\n JuliaHub.application(:default, \"Julia IDE\")\n JuliaHub.application(:default, \"Pluto\")\n JuliaHub.application(:default, \"Windows Workstation\")\n\njulia> JuliaHub.applications(:package)\n2-element Vector{JuliaHub.PackageApp}:\n JuliaHub.application(:package, \"RegisteredPackageApp\")\n JuliaHub.application(:package, \"CustomDashboardApp\")\n\njulia> JuliaHub.applications(:user)\n1-element Vector{JuliaHub.UserApp}:\n JuliaHub.application(:user, \"ExampleApp.jl\")\n\n\ncompat: Experimental API\nApplications-related APIs are experimental, and may be changed or removed without notice.\n\n\n\n\n\n","category":"function"},{"location":"reference/job-submission/#JuliaHub.application","page":"Job submission","title":"JuliaHub.application","text":"JuliaHub.application(\n    category::Symbol, name::AbstractString;\n    throw::Bool=true, [auth::Authentication]\n) -> AbstractJuliaHubApp\n\nReturns the application corresponding to name from the specified category of applications. Will throw an InvalidRequestError if the application can't be found, or returns nothing in this situation if throw=false is passed.\n\ncategory specifies the application category and must be one of: :default, :package, or :user. This is necessary to disambiguate apps with the same name in the different categories.\n\nSee also: applications.\n\nExamples\n\njulia> JuliaHub.applications()\n7-element Vector{JuliaHub.AbstractJuliaHubApp}:\n JuliaHub.application(:default, \"Linux Desktop\")\n JuliaHub.application(:default, \"Julia IDE\")\n JuliaHub.application(:default, \"Pluto\")\n JuliaHub.application(:default, \"Windows Workstation\")\n JuliaHub.application(:package, \"RegisteredPackageApp\")\n JuliaHub.application(:package, \"CustomDashboardApp\")\n JuliaHub.application(:user, \"ExampleApp.jl\")\n\ncompat: Experimental API\nApplications-related APIs are experimental, and may be changed or removed without notice.\n\n\n\n\n\n","category":"function"},{"location":"reference/job-submission/#JuliaHub.DefaultApp","page":"Job submission","title":"JuliaHub.DefaultApp","text":"struct DefaultApp <: AbstractJuliaHubApp\n\nRepresents a default JuliaHub instance application, and they can be started as jobs with submit_job.\n\nThe list of available applications can be accessed via the applications function, and specific applications can be picked out with application.\n\njulia> apps = JuliaHub.applications(:default)\n4-element Vector{JuliaHub.DefaultApp}:\n JuliaHub.application(:default, \"Linux Desktop\")\n JuliaHub.application(:default, \"Julia IDE\")\n JuliaHub.application(:default, \"Pluto\")\n JuliaHub.application(:default, \"Windows Workstation\")\n\njulia> JuliaHub.application(:default, \"Pluto\")\nDefaultApp\n name: Pluto\n key: pluto\n\ncompat: Experimental API\nApplications-related APIs are experimental, and may be changed or removed without notice.\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.PackageApp","page":"Job submission","title":"JuliaHub.PackageApp","text":"struct PackageApp <: AbstractJuliaHubApp\n\nRepresents a JuliaHub package application that is available in one of the instance's package registries. These packages can be started as JuliaHub jobs with submit_job.\n\nThe list of available applications can be accessed via the applications function, and specific applications can be picked out with application.\n\njulia> apps = JuliaHub.applications(:package)\n2-element Vector{JuliaHub.PackageApp}:\n JuliaHub.application(:package, \"RegisteredPackageApp\")\n JuliaHub.application(:package, \"CustomDashboardApp\")\n\njulia> JuliaHub.application(:package, \"RegisteredPackageApp\")\nPackageApp\n name: RegisteredPackageApp\n uuid: db8b4d46-bfad-4aa5-a5f8-40df1e9542e5\n registry: General (23338594-aafe-5451-b93e-139f81909106)\n\nSee also: help.juliahub.com on applications\n\ncompat: Experimental API\nApplications-related APIs are experimental, and may be changed or removed without notice.\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.UserApp","page":"Job submission","title":"JuliaHub.UserApp","text":"struct UserApp <: AbstractJuliaHubApp\n\nRepresents a private application that has been added to the user account via a Git repository. These applications can be started as JuliaHub jobs with submit_job.\n\nThe list of available applications can be accessed via the applications function, and specific applications can be picked out with application.\n\njulia> apps = JuliaHub.applications(:user)\n1-element Vector{JuliaHub.UserApp}:\n JuliaHub.application(:user, \"ExampleApp.jl\")\n\njulia> JuliaHub.application(:user, \"ExampleApp.jl\")\nUserApp\n name: ExampleApp.jl\n repository: https://github.com/JuliaHubExampleOrg/ExampleApp.jl\n\nSee also: help.juliahub.com on applications\n\ncompat: Experimental API\nApplications-related APIs are experimental, and may be changed or removed without notice.\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.ApplicationJob","page":"Job submission","title":"JuliaHub.ApplicationJob","text":"struct ApplicationJob <: AbstractJobConfig\n\nAbstractJobConfig that wraps a DefaultApp. This is primarily used internally and should rarely be constructed explicitly.\n\n\n\n\n\n","category":"type"},{"location":"reference/job-submission/#JuliaHub.PackageJob","page":"Job submission","title":"JuliaHub.PackageJob","text":"struct PackageJob <: AbstractJobConfig\n\nAbstractJobConfig that wraps a PackageApp or UserApp. This is primarily used internally and should rarely be constructed explicitly.\n\nConstructors\n\nJuliaHub.PackageJob(app::Union{JuliaHub.PackageApp,JuliaHub.UserApp}; [sysimage::Bool = false])\n\nCan be used to construct a PackageApp or UserApp based job, but allows for some job parameters to be overridden. Currently, only support the enabling of a system image based job by setting sysimage = true.\n\njulia> app = JuliaHub.application(:package, \"RegisteredPackageApp\")\nPackageApp\n name: RegisteredPackageApp\n uuid: db8b4d46-bfad-4aa5-a5f8-40df1e9542e5\n registry: General (23338594-aafe-5451-b93e-139f81909106)\n\njulia> JuliaHub.submit_job(JuliaHub.PackageJob(app; sysimage = true))\nJuliaHub.Job: jr-xf4tslavut (Submitted)\n submitted: 2023-03-15T07:56:50.974+00:00\n started:   2023-03-15T07:56:51.251+00:00\n finished:  2023-03-15T07:56:59.000+00:00\n\n\n\n\n\n","category":"type"},{"location":"#JuliaHub.jl","page":"Home","title":"JuliaHub.jl","text":"The JuliaHub.jl package offers a programmatic Julia interface to the JuliaHub platform.\n\nWith JuliaHub.jl you can do things such as start JuliaHub jobs, access job outputs, and manage your datasets, programmatically, directly in the REPL or in your Julia script. It can also be used in JuliaHub jobs to interact with the platform (to upload datasets, for example).\n\nIf you are unfamiliar with JuliaHub.jl, you may want to start out by reading through the package's Getting Started tutorial. If you want to know in detail how to programmatically work with a particular JuliaHub feature, you may want to skim through the applicable how-to guide:\n\nPages = Main.PAGES_GUIDES\nDepth = 1:1\n\nFinally, detailed explanations and API references of JuliaHub.jl features and functions are available in the reference section of the manual:\n\nPages = Main.PAGES_REFERENCE\nDepth = 1:1\n\ntip: JuliaHub platform documentation\nThe documentation here focuses on working with the JuliaHub.jl Julia library. See the main JuliaHub documentation to learn more about the JuliaHub platform, and see product (e.g. JuliaSim) documentation for product-specific questions.\n\nnote: Enterprise use\nJuliaHub.jl works with both juliahub.com and private enterprise instances. For enterprise users: the instance URL can be passed to the authenticate function either directly via an argument, or via the JULIA_PKG_SERVER environment variable.\n\n","category":"section"}]
}
